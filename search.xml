<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue常见问题(一)</title>
    <url>/2024/04/24/Vue%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="Vue数据绑定原理"><a href="#Vue数据绑定原理" class="headerlink" title="Vue数据绑定原理"></a>Vue数据绑定原理</h2><p><strong>Vue数据绑定采用 <code>数据劫持</code> 和 <code>订阅者-发布者</code> 结合的模式。</strong></p>
<ol>
<li><p>Vue2中，使用ES5中引入的 <code>defineProperty</code> 方法,它可以在一个对象上定义一个新属性，或者修改一个对象的现有属性,并返回这个对象。</p>
<p><em>语法：</em> <code>Object.defineProperty(obj, prop, descriptor)</code></p>
<p>Object.defineProperty还有一个重要的特性：<strong>它可以定义访问器属性</strong>。访问器属性不包含数据值，而是由一对 <code>getter</code> 和 <code>setter</code> 函数来获取或设置值。通过使用访问器属性，我们可以实现数据绑定、验证、计算等功能。这也是Vue2的数据响应的原理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个空对象</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.defineProperty给obj添加一个fullName属性，该属性由firstName和lastName组成，并且不能直接修改。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;fullName&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Cannot set fullName directly&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给obj添加firstName和lastName两个普通属性，并赋值。</span></span><br><span class="line">obj.<span class="property">firstName</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">obj.<span class="property">lastName</span> = <span class="string">&#x27;Cruise&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印obj.fullName</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">fullName</span>); <span class="comment">// Tom Cruise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改obj.fullName</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  obj.<span class="property">fullName</span> = <span class="string">&#x27;Jerry Seinfeld&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">message</span>); <span class="comment">// Cannot set fullName directly </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 <code>Vue2</code> 中, 需要使用 **<code>observe</code>**将数据对象进行递归遍历, 给对象的属性以及子属性对象的属性加上 <code>setter</code> 和 <code>getter</code> 用于监听数据变化。</p>
<p>在这基础上，**<code>compile</code>** 解析模版指令，将数据渲染到页面上。初始化渲染时，给每个节点添加相应的更新函数进行绑定。</p>
<p><code>watcher</code> 是作为订阅者的角色, 用以沟通 <code>observe</code> 和 <code>compile</code>:</p>
<p>​	当数据变化时 <code>dep.notify()</code> 发出通知, 订阅者 <code>watcher</code> 调用自身的 <code>update()</code> 方法, 触发 <code>compile</code> 的回调, 进行重新渲染。</p>
<p>​	视图变化时，触发事件绑定的回调函数，调用数据对象的 <code>set</code> 方法修改数据。</p>
<p>从而实现数据的<strong>双向绑定</strong>。</p>
</li>
<li><p>Vue3中, 使用 <code>Proxy</code> 实现数据绑定。Proxy是ES6中引入的一个新对象，它可以创建一个代理对象（proxy object），该代理对象可以拦截并改变对目标对象（target object）的各种操作。使用Proxy，我们不仅可以对单个属性进行控制，还可以对整个对象进行控制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个目标对象targetObj，包含name和age两个普通属性。</span></span><br><span class="line"><span class="keyword">let</span> targetObj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一个代理对象proxyObj，并传入目标对象targetObj作为第一个参数。</span></span><br><span class="line"><span class="keyword">let</span> proxyObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObj, &#123;</span><br><span class="line">  <span class="comment">// 定义get拦截器函数，在读取代理对象任何属性时触发。</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果读取不存在的属性，则返回undefined。</span></span><br><span class="line">    <span class="keyword">if</span> (!(prop <span class="keyword">in</span> target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果读取name属性，则在后面加上&#x27;(proxy)&#x27;字样。</span></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop] + <span class="string">&#x27;(proxy)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况下正常返回目标对象相</span></span><br><span class="line"><span class="keyword">return</span> target[prop];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义set拦截器函数，在修改代理对象任何属性时触发。</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果修改name属性，则抛出错误，不允许修改。</span></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Cannot set name property&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果修改age属性，则检查值是否为合法的数字，如果不是，则抛出错误，如果是，则更新目标对象相应属性的值。</span></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span> || <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Age must be a valid number&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      target[prop] = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况下正常更新目标对象相应属性的值。</span></span><br><span class="line">    target[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印proxyObj.name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyObj.<span class="property">name</span>); <span class="comment">// Tom(proxy)</span></span><br><span class="line"><span class="comment">// 打印proxyObj.age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyObj.<span class="property">age</span>); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改proxyObj.name</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  proxyObj.<span class="property">name</span> = <span class="string">&#x27;Jerry&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">message</span>); <span class="comment">// Cannot set name property </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改proxyObj.age</span></span><br><span class="line">proxyObj.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line"><span class="comment">// 打印proxyObj.age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyObj.<span class="property">age</span>); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>react 进阶技巧</title>
    <url>/2024/04/24/react%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><h2 id="reac性能问题和优化"><a href="#reac性能问题和优化" class="headerlink" title="reac性能问题和优化"></a>reac性能问题和优化</h2><h2 id="react-router的使用"><a href="#react-router的使用" class="headerlink" title="react-router的使用"></a>react-router的使用</h2>]]></content>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title>react 实战技巧</title>
    <url>/2024/04/24/react%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="react中的全局状态管理"><a href="#react中的全局状态管理" class="headerlink" title="react中的全局状态管理"></a>react中的全局状态管理</h2><h2 id="react中的路由权限控制"><a href="#react中的路由权限控制" class="headerlink" title="react中的路由权限控制"></a>react中的路由权限控制</h2><h2 id="组件库等相关生态"><a href="#组件库等相关生态" class="headerlink" title="组件库等相关生态"></a>组件库等相关生态</h2>]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经-JS（一）</title>
    <url>/2024/04/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F-JS(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Q1-延迟加载的方法有哪些"><a href="#Q1-延迟加载的方法有哪些" class="headerlink" title="Q1: 延迟加载的方法有哪些"></a>Q1: 延迟加载的方法有哪些</h3><p><code>async</code>和<code>defer</code>属性都用于指定脚本的加载方式，将脚本与HTML文档的解析和渲染过程分离，以避免阻塞页面的呈现。因此，通过使用defer属性或async属性，可以优化页面加载性能，避免脚本阻塞文档的解析过程。</p>
<ol>
<li><p><code>aysnc</code><br>目的：不让页面等待脚本下载和执行，从而<strong>异步加载页面其他内容</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test2.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 这里放内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span>  </span><br></pre></td></tr></table></figure>

<p>当浏览器遇到带有 <code>async</code> 属性的脚本标签时，它会开始异步下载脚本，并在下载完成后立即执行。使用<code>async</code>属性时，脚本的执行顺序不受保证。如果有多个带有<code>async</code>属性的脚本，它们可能会以任意顺序执行，因此脚本之间的依赖关系需要谨慎处理。</p>
</li>
<li><p><code>defer</code>: 当浏览器遇到带有 <code>defer</code> 属性的脚本标签时，它会开始异步下载脚本，但会等到文档解析完成后再执行脚本。这意味着脚本的加载不会阻塞页面的呈现，但它们将按照它们在文档中的顺序执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test2.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 这里放内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span>  </span><br></pre></td></tr></table></figure>

<p>使用<code>defer</code>属性时，脚本的执行被延迟到文档解析完成之后，但在<code>DOMContentLoaded</code>事件触发之前。这使得脚本能够在文档完全解析之前对DOM进行操作。</p>
</li>
</ol>
<blockquote>
<p>需要注意的是，<code>async</code>和<code>defer</code>属性只适用于外部脚本（通过<code>src</code>属性引入的脚本），不适用于内联脚本（直接在HTML文件中编写的脚本）。也就是说，这些属性只对外部脚本起作用，而不会影响内联脚本的加载和执行方式。</p>
</blockquote>
<blockquote>
<p>不同之处在于，使用defer属性的脚本会按照它们在文档中出现的顺序执行，而使用async属性的脚本则会在加载完成后立即执行，不考虑它们在文档中的位置。</p>
</blockquote>
<ol start="3">
<li><p>其他</p>
<ol>
<li><p>动态加载脚本（Dynamic Script）：<br>动态加载脚本是一种使用JavaScript在页面中插入一个新的<script>标签来加载脚本的方式。这种方式可以通过异步或延迟属性来控制脚本加载的方式。动态加载脚本最大的优点是可以根据页面的具体情况来加载所需的脚本，避免一次性加载过多的脚本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">async</span> = <span class="literal">true</span>; <span class="comment">// 或者 script.defer = true;</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;example.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>
</li>
<li><p>按需加载脚本（Lazy Load Script）：<br>按需加载脚本是一种在特定时刻才加载脚本的方式，而不是在页面加载完成后立即加载。这种方式可以减少页面的初始加载体积，加快页面的加载速度，提升用户体验。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = <span class="string">&#x27;example.js&#x27;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要的时候调用loadScript函数来加载脚本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>setTimeOut</p>
</li>
</ol>
</li>
</ol>
<h3 id="Q2-数据类型"><a href="#Q2-数据类型" class="headerlink" title="Q2: 数据类型"></a>Q2: 数据类型</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote>
<p>基本类型: number, string, Boolean, null, undefined, symbol, bigInt </p>
<p>引用类型: object => function, array</p>
</blockquote>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><ol>
<li>字符串相加为连接字符串  <code>&#39;name&#39;+true</code>  //nametrue</li>
<li>布尔值跟数字相加得数字  <code>true + 1</code>  //2</li>
<li><code>undefined + 1</code> // NAN</li>
<li><code>typeof(NAN)</code>  //number</li>
<li><code>typeof(undefined)</code>  //undefined</li>
<li><code>typeof(null)</code>  // Object</li>
</ol>
<h3 id="Q3-null-和-undefined"><a href="#Q3-null-和-undefined" class="headerlink" title="Q3: null 和 undefined"></a>Q3: null 和 undefined</h3><ol>
<li><code>null</code> 和 <code>undefined</code> 都表示空,无值</li>
<li><code>null</code> 会被隐式转换成 0, 出现错误不易发现</li>
<li><code>undefined</code> 转换为 <code>NaN</code></li>
<li>typeof(null) 和 typeof(undefined)</li>
</ol>
<h3 id="Q4-和"><a href="#Q4-和" class="headerlink" title="Q4: "==" 和  "===""></a>Q4: "==" 和  "==="</h3><p><code>==</code> 判断值是否相等</p>
<ol>
<li><code>null</code> 和 <code>undefined</code></li>
<li>string 和 number, 会进行隐式转换, 把 <code>string</code> 转换成 <code>number</code></li>
<li>boolean 和 number, 会进行隐式转换, 把 <code>boolean</code> 转换成 <code>number</code></li>
<li>隐式转换的原理是使用 <code>MathObj.valueOf()</code> 方法</li>
<li>object 和 其他: 会将object 转换成基本类型(string || number)</li>
</ol>
<p><code>===</code> 既判断值也判断类型</p>
<h3 id="Q5-微任务或者宏任务"><a href="#Q5-微任务或者宏任务" class="headerlink" title="Q5: 微任务或者宏任务"></a>Q5: 微任务或者宏任务</h3><p>JavaScript是单线程的编程语言</p>
<blockquote>
<p>JS执行流程: 同步任务 -> 事件循环 [微任务 / 宏任务]</p>
<p>进入事件循环： 请求，定时器， 事件</p>
</blockquote>
<p><strong>面试题:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11111</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;,<span class="number">1000</span>*<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">22222</span>)</span><br><span class="line">问: 几秒输出几</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p>11111</p>
<p>22222</p>
<p>3	隔一秒</p>
<p>3	隔一秒</p>
<p>3</p>
</blockquote>
<ol>
<li>宏任务</li>
</ol>
<blockquote>
<p>setTimeOut、setInterval</p>
</blockquote>
<ol start="2">
<li>微任务</li>
</ol>
<blockquote>
<p>promise.then</p>
</blockquote>
<ol start="3">
<li><p>执行宏任务的前提是执行完所有的微任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span> <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1 promise1&#x27;</span>);<span class="comment">//同步</span></span><br><span class="line">	<span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微1&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微2&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);<span class="comment">//同步</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Q6-作用域"><a href="#Q6-作用域" class="headerlink" title="Q6: 作用域"></a>Q6: 作用域</h3><ol>
<li><p>除函数外, JS不存在快作用域</p>
</li>
<li><p>作用域链: 内部作用域可以访问外部变量, 外部不能访问内部的</p>
</li>
<li><p><strong>注意: 变量声明时没有 <code>var</code> 是全局定义</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> a = b = <span class="number">10</span>;  </span><br><span class="line">&#125;)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>此处的 <code>var a = b = 10</code> 相当于 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  </span><br><span class="line"> b = <span class="number">0</span>  <span class="comment">// b 为全局变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量提升机制</p>
<p>优先级:</p>
<p>提升机制提升时, 函数声明优先于变量声明. 但当变量已经定义后, 它的优先级大于普通函数声明</p>
<p>参数优先级大于变量提升</p>
<p>题1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(b )</span><br><span class="line">		<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(b )</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="title function_">a</span>();</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(b )</span><br><span class="line">	&#125;</span><br><span class="line"><span class="title function_">c</span>();	<span class="comment">// undefinede 2 1</span></span><br></pre></td></tr></table></figure>

<p>题2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> name =<span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> name =<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>+name);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;222&#x27;</span>+name);</span><br><span class="line">&#125;)()	<span class="comment">// 111b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em><strong>提升机制提升时, 函数声明优先于变量声明. 但当变量已经定义后, 它的优先级大于普通函数声明</strong></em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a )</span><br><span class="line">    <span class="keyword">var</span> a =<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;&#125;</span><br><span class="line"><span class="title function_">fun</span>();	<span class="comment">// function a()&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> a =<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a )</span><br><span class="line">	&#125;</span><br><span class="line"><span class="title function_">fun</span>();	<span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Q7-JS对象"><a href="#Q7-JS对象" class="headerlink" title="Q7: JS对象"></a>Q7: JS对象</h3><ol>
<li><p>使用 <code>new</code> 操作符新建一个对象</p>
</li>
<li><p>对象的 <code>key</code> 都是字符串值</p>
</li>
<li><p>对象之间不相等, 除了引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>] === [<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>]	<span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = obj2</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2)	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>面试题</p>
<p>题1: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 =</span><br><span class="line">	<span class="attr">a</span>:<span class="string">&#x27;hellow&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.<span class="property">a</span>=<span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>题2：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;；</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">	<span class="attr">key</span>:<span class="string">&#x27;a&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">	<span class="attr">key</span>:<span class="string">&#x27;c&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">a[b]=<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;456&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b])	<span class="comment">// 456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象属性查找:</p>
<blockquote>
<p>函数对象的原型链: 对象本身 -> 构造函数 -> 对象原型 -> 构造函数原型 -> 对象上一层原型</p>
</blockquote>
</li>
</ol>
<h3 id="Q8-this指针综合"><a href="#Q8-this指针综合" class="headerlink" title="==Q8: this指针综合=="></a>==Q8: this指针综合==</h3><ol>
<li><p><code>this</code> 基本来说指向当前对象</p>
</li>
<li><p>题1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11111</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;aaaaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun);	<span class="comment">//打印的是函数体</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fun</span>());		<span class="comment">// 执行函数，打印返回值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">fun</span>())		<span class="comment">// 打印function对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">xxx</span> = <span class="string">&#x27;xxx&#x27;</span>		<span class="comment">// this指向Function对象， 属性会在对象中</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) 		<span class="comment">// 普通函数的 this 指向 window 对象</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;aaaaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">fun</span>())		<span class="comment">// fun &#123;xxx: &#x27;xxx&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>题2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">	getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> getName=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); 	<span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>();		<span class="comment">//4 </span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>();		<span class="comment">// 1</span></span><br><span class="line"><span class="title function_">getName</span>();		<span class="comment">//1 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>();	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>题3</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;ByteDance&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getA</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> )</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">let</span> funcA = a.<span class="property">getA</span>;</span><br><span class="line"><span class="title function_">funcA</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>题4</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">length</span>: <span class="number">5</span>,</span><br><span class="line">	<span class="attr">test1</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">test2</span> = fn;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">test1</span>())	<span class="comment">// 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>() === obj.<span class="title function_">test2</span>())		<span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">test1</span>() == obj.<span class="title function_">test2</span>())		<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Q9：-数组相关的问题"><a href="#Q9：-数组相关的问题" class="headerlink" title="Q9： 数组相关的问题"></a>Q9： 数组相关的问题</h3><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><h4 id="判断数组的方法"><a href="#判断数组的方法" class="headerlink" title="判断数组的方法"></a>判断数组的方法</h4><ol>
<li><p><code>instanceof</code> 判断原型链上是否含有xxx</p>
<p><code> obj instanceof Object</code> : 在 <code>obj</code> 的原型链上是否含有 <code>Object</code></p>
</li>
<li><p><code>isArray</code> 判断是否是数组</p>
</li>
<li><p><code>arr.prototype.toString()</code> : 输出变量的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>() &gt; -<span class="number">1</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>arr.protoype.isPrototypeOf()</code></p>
<p><strong><code>isPrototypeOf()</code></strong> 方法用于检查一个对象是否存在于另一个对象的原型链中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(arr))</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><ol>
<li><p><strong>Set</strong> 数据类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]:</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr1))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="keyword">new</span> <span class="title class_">Set</span>(arr1)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 <code>indexOf</code> </p>
<p><code>indexOf</code> 可以返回数组下标，如果不存在返回 -1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr </span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> brr = []</span><br><span class="line">	arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(brr.<span class="title function_">indexof</span>(arr[i])==-<span class="number">1</span> )</span><br><span class="line">		brr.<span class="title function_">push</span>(arr[i])   </span><br><span class="line">	<span class="keyword">return</span> brr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>sort</code> </p>
<p>排序后利用前后元素不相等筛选</p>
</li>
</ol>
<h3 id="Q10-字符串相关问题"><a href="#Q10-字符串相关问题" class="headerlink" title="Q10: 字符串相关问题"></a>Q10: 字符串相关问题</h3><h4 id="给字符串新增方法实现功能"><a href="#给字符串新增方法实现功能" class="headerlink" title="给字符串新增方法实现功能"></a>给字符串新增方法实现功能</h4><p>给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前<br>缀的字符串，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;world&quot;</span>.<span class="title function_">addPrefix</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line"><span class="comment">// 控制台会输出：&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addPrefix</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;world&quot;</span>.<span class="title function_">addPrefix</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意此处不能使用 箭头函数 来声明方法</strong> </p>
<h4 id="统计字符数量"><a href="#统计字符数量" class="headerlink" title="统计字符数量"></a>统计字符数量</h4><ol>
<li><p>利用 <code>charAt</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;aaabbbbbccddddddddddx&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">var</span> char str.<span class="title function_">charAt</span>(i);</span><br><span class="line">	<span class="keyword">if</span>(obj[char])&#123;</span><br><span class="line">		obj [char]++;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		obj [char]<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj )</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 <code>map</code> 数据结构</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>react基本使用</title>
    <url>/2024/04/24/react%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="react项目创建和目录结构"><a href="#react项目创建和目录结构" class="headerlink" title="react项目创建和目录结构"></a>react项目创建和目录结构</h2><ol>
<li><p>创建项目</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npx create-react-app &lt;projectName&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>核心库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDom from &#x27;react-dom/client&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A[App组件] --&gt; B[Page1组件]</span><br><span class="line">    A[App组件] --&gt; C[Page2组件]</span><br><span class="line">    A[App组件]--&gt; D[Html中的id为root的div]</span><br><span class="line">    D[Html中的id为root的div]--&gt; E[项目显示]</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>其中，<code>Page1</code> 和 <code>Page2</code> 组件为 <code>App</code> 的子组件，由React库负责生成</p>
<p>App组件转化为DOM的过程由 <code>react-dom</code> 负责</p>
</li>
<li><p>根组件渲染</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 渲染你的 React 组件</span><br><span class="line">const root = createRoot(document.getElementById(&#x27;app&#x27;));</span><br><span class="line">root.render(&lt;h1&gt;Hello, world&lt;/h1&gt;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="react组件和jsx"><a href="#react组件和jsx" class="headerlink" title="react组件和jsx"></a>react组件和jsx</h2><h3 id="react-组件"><a href="#react-组件" class="headerlink" title="react 组件"></a><code>react</code> 组件</h3><ol>
<li><p>函数组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Profile() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;</span><br><span class="line">      alt=&quot;Katherine Johnson&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>export default</code>它导出文件中的主要函数以便你以后可以从其他文件引入它。</p>
</li>
<li><p>类组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Profile() extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">      return </span><br><span class="line">      &lt;img</span><br><span class="line">      src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;</span><br><span class="line">      alt=&quot;Katherine Johnson&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出、导入组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Gallery() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h1&gt;了不起的科学家&lt;/h1&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><ol>
<li><p>特点：由于<code>React</code>项目利用<code>babel</code>对语句进行编译，所以可以和js混用。本质是对JS语法的扩展。</p>
<p>使用 React 的 <code>creatElement</code> 方法也能创建组件但是不常用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Profile() &#123;</span><br><span class="line">  return React.creatElement(&#x27;img&#x27;, [</span><br><span class="line">      src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;,</span><br><span class="line">      alt=&quot;Katherine Johnson&quot;], </span><br><span class="line">                            &#x27;&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，<code>React</code> 和 <code>jsx</code> 语法是相互独立的，<code>creatElement</code> 方法会创建一个 <code>React.Element</code> 对象(虚拟DOM)，进而渲染成节点。</p>
</li>
<li><p>jsx 的 <code>&#123;&#125;</code> 渲染原则</p>
<ol>
<li>字符串，数字：直接渲染</li>
<li>方法：无法渲染</li>
<li>对象：无法渲染，只能渲染 <code>Element</code> 对象</li>
<li>布尔值：不渲染</li>
<li>undefined，null：不渲染</li>
<li>数组：每一项单独渲染</li>
<li>表达式：运行之后渲染</li>
</ol>
</li>
</ol>
<h2 id="react的事件绑定"><a href="#react的事件绑定" class="headerlink" title="react的事件绑定"></a>react的事件绑定</h2><ol>
<li><p>react 事件绑定和原生js相似（首字母大写）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Click me</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>this</code>指向：</p>
<p><strong>不做任何处理，默认this指向 <code>undefined</code></strong></p>
<p>如果你像下面这样写事件监听函数，浏览器一定会给你报语法错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// JSX</span><br><span class="line">class Test extends React.Component &#123;</span><br><span class="line"> handleClick () &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line"> render () &#123;</span><br><span class="line"> return &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  // undefined</span><br></pre></td></tr></table></figure>

<p>此时如果你点击 <code>button</code> 按钮，会输出 <code>undefined</code>。</p>
<p>注意此处的**<code>return &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt;</code>**，<code>this.handleClick</code> 不带括号，<code>this.handleClick()</code>为函数调用。</p>
<p><em>解决方案：</em></p>
<p>我们知道你可以通过 <code>bind</code> 方法或者箭头函数来强制绑定 <code>this</code> 来避免这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>或者使用箭头函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>如果this没有绑定到当前对象，那此时 <code>this</code> 到底指向了谁？是 <code>undefined</code> 还是全局对象，比如 <code>window</code>？（根据前面提到的浏览器报错信息，答案显然是 <code>undefined</code>）</p>
</li>
<li><p>为什么 React 组件的实例会失去指向它本身的 <code>this</code> 指向？</p>
</li>
<li><p>这是 JavaScript 语言本身导致的还是 React 的内部某些原因导致的呢？</p>
<p><strong>知乎：<a href="https://zhuanlan.zhihu.com/p/37911534">深入解读 React 组件中的 “this</a></strong></p>
</li>
</ul>
<ol start="3">
<li><p>事件绑定操作：</p>
<ol>
<li><p>事件传参：<code>bind(this, arg1, arg2 ... )</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件对象：默认传递给方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// JSX</span><br><span class="line">class Test extends React.Component &#123;</span><br><span class="line"> handleClick (arg1,..., e) &#123;</span><br><span class="line">  console.log(e)</span><br><span class="line">  &#125;</span><br><span class="line"> render () &#123;</span><br><span class="line"> return &lt;button onClick=&#123;this.handleClick.bind(this, arg1...)&#125;&gt;&lt;/button&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  // undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>阻止默认行为和阻止冒泡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleClick (arg1,..., e) &#123;</span><br><span class="line"> e.<span class="title function_">stopPropagation</span>()  <span class="comment">// 阻止冒泡</span></span><br><span class="line"> e.<span class="title function_">preventDefult</span>()  <span class="comment">//阻止默认行为</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="react中的响应式数据"><a href="#react中的响应式数据" class="headerlink" title="react中的响应式数据"></a>react中的响应式数据</h2><h2 id="条件渲染和列表循环"><a href="#条件渲染和列表循环" class="headerlink" title="条件渲染和列表循环"></a>条件渲染和列表循环</h2><h2 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h2><h2 id="props和组件间的传值，插槽"><a href="#props和组件间的传值，插槽" class="headerlink" title="props和组件间的传值，插槽"></a>props和组件间的传值，插槽</h2><h2 id="react中的样式操作"><a href="#react中的样式操作" class="headerlink" title="react中的样式操作"></a>react中的样式操作</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="实战编写增伤改查列表"><a href="#实战编写增伤改查列表" class="headerlink" title="实战编写增伤改查列表"></a>实战编写增伤改查列表</h2><h2 id="ref和context"><a href="#ref和context" class="headerlink" title="ref和context"></a>ref和context</h2><h2 id="函数组件和hook"><a href="#函数组件和hook" class="headerlink" title="函数组件和hook"></a>函数组件和hook</h2>]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经-Vue(一)</title>
    <url>/2024/04/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F-Vue(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="关于生命周期"><a href="#关于生命周期" class="headerlink" title="关于生命周期"></a><strong>关于生命周期</strong></h2><h3 id="生命周期有哪些-在那里发送请求？"><a href="#生命周期有哪些-在那里发送请求？" class="headerlink" title="生命周期有哪些,在那里发送请求？"></a>生命周期有哪些,在那里发送请求？</h3><p><strong>生命周期：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate	// 初始化之后调用</span><br><span class="line">created  // 完成data observe 和 watch, 此时 $el 不可见</span><br><span class="line">beforeMount		// 首次调用 render函数</span><br><span class="line">mounted  // 将虚拟DOM挂载到 DOM上</span><br><span class="line">beforeUpdate  // 数据更新，$el未更新,可以访问现有DOM, 只在客户端渲染, 服务端只会初次渲染</span><br><span class="line">updated  // $el更新</span><br><span class="line">activated dectivated // keep-alive中调用</span><br><span class="line">beforeDestroy	// 销毁之前，$el 仍然可用</span><br><span class="line">destroyed  // 解绑实例，子实例和监视器也被销毁</span><br></pre></td></tr></table></figure>

<p><strong>发送请求：</strong><br>一般来说，在 <code>created</code> 和 <code>mounted </code> 都是可以的，但是，如果父子组件都会发送请求，这样就需要考虑父子生命周期的加载顺序。</p>
<h3 id="一旦进入组件，会执行哪些生命周期？"><a href="#一旦进入组件，会执行哪些生命周期？" class="headerlink" title="一旦进入组件，会执行哪些生命周期？"></a>一旦进入组件，会执行哪些生命周期？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate	created</span><br><span class="line">beforeMount		mounted</span><br></pre></td></tr></table></figure>

<h3 id="※-父组件引入子组件，执行生命周期的顺序是？"><a href="#※-父组件引入子组件，执行生命周期的顺序是？" class="headerlink" title="※ 父组件引入子组件，执行生命周期的顺序是？"></a>※ 父组件引入子组件，执行生命周期的顺序是？</h3><p>父：<code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code></p>
<p>子：<code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code> &#x3D;&gt; <code>mounted</code> </p>
<p>……</p>
<p>父：<code>mounted</code></p>
<h3 id="※-为什么发送请求不在beforeCreate-它与created有什么不同？"><a href="#※-为什么发送请求不在beforeCreate-它与created有什么不同？" class="headerlink" title="※ 为什么发送请求不在beforeCreate,它与created有什么不同？"></a>※ 为什么发送请求不在<code>beforeCreate</code>,它与<code>created</code>有什么不同？</h3><p>在 <code>beforeCreate</code> 阶段，系统&#x2F; <code>beforeCreate</code> 无法调用 methods 中的方法，如果请求封装在方法中，那就无法发送<br>如果直接异步获取，在哪个生命周期都可以（ <code>beforeCreate</code> &#x2F; <code>created</code> &#x2F; <code>mounted</code>)</p>
<h3 id="在created中如何获取DOM信息？"><a href="#在created中如何获取DOM信息？" class="headerlink" title="在created中如何获取DOM信息？"></a>在<code>created</code>中如何获取DOM信息？</h3><p>在 <code>created</code> 中使用 <code>this.$el</code> 异步的请求就可以获取到DOM信息。<br>    原理是异步请求在同步请求完成之后进行，这样即可保存当前的参数信息，在生命周期执行完毕后输出。比如 <code>setTimeOut(callback, time)</code>, <code>Promise()</code>, <code>aysnc + awiat</code> 和<code>this.nextTick(callback)</code>(Vue内置的异步方法)。</p>
<h3 id="keep-alive有什么作用，使用keep-alive后会执行什么生命周期？"><a href="#keep-alive有什么作用，使用keep-alive后会执行什么生命周期？" class="headerlink" title="keep-alive有什么作用，使用keep-alive后会执行什么生命周期？"></a><code>keep-alive</code>有什么作用，使用<code>keep-alive</code>后会执行什么生命周期？</h3><ol>
<li><code>keep-alive</code> 用于缓存组件的信息。<br> 如果将组件置入<code>keep-alive</code>中，系统会缓存组件信息</li>
<li>使用时会多出两个生命周期：<br> <code>activated</code>	<code>deactivated</code></li>
<li>加入后，第一次的执行顺序为，<code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code> &#x3D;&gt; <code>mounted</code> &#x3D;&gt; <code>activated</code></li>
</ol>
<h3 id="第二次或第N次进入组件，生命周期的执行顺序："><a href="#第二次或第N次进入组件，生命周期的执行顺序：" class="headerlink" title="第二次或第N次进入组件，生命周期的执行顺序："></a>第二次或第N次进入组件，生命周期的执行顺序：</h3><ol>
<li>使用<code>keep-alive</code>组件后，第一次的执行顺序为: <code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code> &#x3D;&gt; <code>mounted</code> &#x3D;&gt; <code>activated</code>。<br> 而第二次只执行 <code>deactived</code>。</li>
<li>没有使用时，会执行 <code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code> &#x3D;&gt; <code>mounted</code>。</li>
</ol>
<h3 id="在什么情况下用过哪些生命周期，场景有？"><a href="#在什么情况下用过哪些生命周期，场景有？" class="headerlink" title="在什么情况下用过哪些生命周期，场景有？"></a>在什么情况下用过哪些生命周期，场景有？</h3><ul>
<li>·发送请求时</li>
<li>进入详情页（关注内容变化）</li>
<li>关闭页面（切换路由）&#x3D;&gt; 参数收集</li>
</ul>
<h2 id="关于组件"><a href="#关于组件" class="headerlink" title="关于组件"></a>关于组件</h2><h3 id="组件通信的分类以及实现方法："><a href="#组件通信的分类以及实现方法：" class="headerlink" title="组件通信的分类以及实现方法："></a>组件通信的分类以及实现方法：</h3><p><em>父传子</em></p>
<ol>
<li>父组件绑定数据到子组件，子组件使用<code>props</code>引入数据：</li>
<li>直接使用<code>this.$parent.xxx</code></li>
<li>使用<code>provide、inject</code>依赖注入</li>
</ol>
<p><em>子传父</em></p>
<ol>
<li><p>子组件中：<code>vm.$emit( event, arg );</code> 触发当前实例上的事件, arg是传递给父组件的参数。</p>
<p>父组件中：<code>vm.$on( event, fn );</code> 监听event事件后运行 fn。</p>
<p><code>vm.$off(&quot;showCityName&quot;);</code> 移除自定义事件监听器。</p>
<ul>
<li>如果没有提供参数，则移除所有的事件监听器；</li>
<li>如果只提供了事件，则移除该事件所有的监听器；</li>
<li>如果同时提供了事件与回调，则只移除这个回调的监听器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    城市：&#123;&#123; city &#125;&#125;</span><br><span class="line">    &lt;button type=&quot;button&quot; @click=&quot;myfun(&#x27;大连&#x27;, &#x27;武汉&#x27;)&quot;&gt;子组件按钮点击&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;city&quot;],</span><br><span class="line">  mounted() &#123;</span><br><span class="line">      this.$on(&#x27;showCityName&#x27;,r=&gt;&#123;</span><br><span class="line">          console.log(r);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myfun(x) &#123;</span><br><span class="line">      this.$emit(&quot;showCityName&quot;, x);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  destoryed() &#123;</span><br><span class="line">    this.$off(&quot;showCityName&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>this.children[0].xxx</code></p>
</li>
<li><p><code>this.refs()</code></p>
</li>
</ol>
<p><em>兄弟组件之间传递消息</em></p>
<ol>
<li><p>使用 <code>eventBus</code></p>
<p>新建一个 <code>bus.js</code>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vue</span>();</span><br></pre></td></tr></table></figure>

<p>然后在你需要触发的 组件中引入 <code>import bus from ‘文件路径’</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bus.$emit(<span class="string">&#x27;触发名称&#x27;</span>, 传输的数据 )      <span class="comment">// 执行</span></span><br></pre></td></tr></table></figure>

<p>最后在你需要的通信的另一个组件中 mounted<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>钩子中执行如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bus.$on(<span class="string">&#x27;触发名称&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写你需要的方法</span></span><br><span class="line">    &#125;)</span><br><span class="line">mounted () &#123;</span><br><span class="line">bus.$on(‘testA’, <span class="variable language_">this</span>.<span class="property">testA</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>由父组件中转</p>
</li>
</ol>
<p>   A: <code>this.$emit(&#39;handleMessage&#39;,message)</code></p>
<p>   B: <code>this.$parent.$on(&#39;messageSent&#39;, this.handleMessage);</code></p>
<h3 id="组件通信相关问题"><a href="#组件通信相关问题" class="headerlink" title="组件通信相关问题"></a>组件通信相关问题</h3><ol>
<li><p>如何找父组件：	<code>this.$parent</code></p>
</li>
<li><p>子组件如何直接修改父组件的值？        <code>this.$parent.xxx = xxx</code></p>
</li>
<li><p>父组件如何直接修改子组件的值？       <code>this.$children[0].xxx = xxx</code></p>
</li>
<li><p>如何找根组件:        <code>this.$root</code></p>
</li>
</ol>
<h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><ul>
<li><em>具名插槽</em></li>
</ul>
<p><code>&lt;BaseLayout&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><code>header.vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template #header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #default&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>匿名插槽</em></li>
</ul>
<p><code>&lt;FancyButton&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FancyButton&gt;</span><br><span class="line">  Click me! &lt;!-- 插槽内容 --&gt;</span><br><span class="line">&lt;/FancyButton&gt;</span><br></pre></td></tr></table></figure>

<p><code>FancyButton.vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;fancy-btn&quot;&gt;</span><br><span class="line">  &lt;slot&gt;</span><br><span class="line">      Submit </span><br><span class="line">    &lt;/slot&gt; &lt;!-- 插槽出口, submit为默认内容 --&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>定义域插槽</em></li>
</ul>
<p><code>&lt;FancyButton&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FancyButton&gt;</span><br><span class="line">  &lt;template #footer = &#123;arr&#125; &gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/FancyButton&gt;</span><br></pre></td></tr></table></figure>

<p><code>FancyButton.vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;fancy-btn&quot;&gt;</span><br><span class="line">  &lt;slot name=&#x27;footer&#x27; :arr = arr&gt;</span><br><span class="line">      Submit </span><br><span class="line">    &lt;/slot&gt; &lt;!-- 插槽出口, submit为默认内容 --&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="provide、inject依赖注入"><a href="#provide、inject依赖注入" class="headerlink" title="provide、inject依赖注入"></a>provide、inject依赖注入</h3><p>父代组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, provide &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;message&#x27;</span>, count)</span><br></pre></td></tr></table></figure>

<p>后代组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">inject</span>(<span class="string">&#x27;message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h3><h3 id="组件中的-name-属性"><a href="#组件中的-name-属性" class="headerlink" title="组件中的 name 属性"></a>组件中的 name 属性</h3><ol>
<li><p>注册组件名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;ComNameHello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>keep-alive</code> 时，搭配组件 <code>name</code> 进行<strong>缓存过滤</strong>, <code>name</code> 可以用作 <code>include</code> 和 <code>exclude</code> 的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Table.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Table&#x27;</span></span><br><span class="line">&#125;，</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getData</span>();</span><br><span class="line">&#125;，</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">   <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span><br><span class="line">          axios.<span class="title function_">get</span>(<span class="string">&#x27;/xx/table.json&#x27;</span>,&#123;</span><br><span class="line">              <span class="attr">params</span>:&#123;</span><br><span class="line">                <span class="attr">id</span>:<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">id</span>  </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            .......</span><br><span class="line">          &#125;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">&lt;div id=&quot;app&quot;&gt; </span><br><span class="line">    &lt;keep-alive exclude=&quot;Table&quot;&gt;</span><br><span class="line">      &lt;router-view/&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在 <code>App.vue</code> 中使用 <code>keep-alive</code> 组件会缓存不活动的组件实例，而不是销毁它们。这样会导致我们滴二次进入页面时不会刷新页面，有两种方式可以解决这样的问题：</p>
<ol>
<li><p>在 <code>keep-alive</code> 中加入 <code>exclude</code> 属性，<code>exclude=&quot;Table&quot;</code> 这样就不会对 Table 组件进行缓存，第二次进入该页面时就会得到最新数据。</p>
</li>
<li><p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。这里把 <code>this.getData()</code> 放到 <code>activated</code> 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">activated</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//第二种解决方案</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getData</span>();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><code>vue-devtools</code> 调试工具中，显示的组见名称由组件<code>name属性</code>决定</p>
</li>
<li><p>组件在当前自身组件中,递归调用自身组件</p>
<p>其实，除了name选项是必须的之外，还有一点也是在实现递归组件要注意的，就是要防止无限递归，造成调用栈溢出，在不满足条件时跳出递归。</p>
<p><code>父组件.vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;tree :model=&quot;treeData&quot;&gt;&lt;/tree&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import tree from &#x27;@/components/tree&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        treeData: &#123;</span><br><span class="line">          title: &#x27;1&#x27;,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;title: &#x27;1-1&#x27;&#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;1-2&#x27;,</span><br><span class="line">              children: [</span><br><span class="line">                &#123;title: &#x27;1-2-1&#x27;&#125;,</span><br><span class="line">                &#123;title: &#x27;1-2-2&#x27;&#125;,</span><br><span class="line">                &#123;title: &#x27;1-2-3&#x27;&#125;,</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;1-3&#x27;,</span><br><span class="line">              children: [</span><br><span class="line">                &#123;</span><br><span class="line">                  title: &#x27;1-3-1&#x27;,</span><br><span class="line">                  children: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      title: &#x27;1-3-1-1&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      title: &#x27;1-3-1-2&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;title: &#x27;1-3-2&#x27;&#125;,</span><br><span class="line">                &#123;title: &#x27;1-3-3&#x27;&#125;,</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><code>tree.vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for=&quot;(item, index) in model&quot; :key=&quot;index&quot;&gt; </span><br><span class="line">        &#123;&#123; item.title &#125;&#125;</span><br><span class="line">      &lt;div v-if=&quot;item.children &amp;&amp; item.children.length&quot;&gt;</span><br><span class="line">        &lt;tree :model=&quot;item.children&quot;&gt;&lt;/tree&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 这里要写name:tree才可以递归</span><br><span class="line">  name: &quot;tree&quot;,</span><br><span class="line">  props: &#123; model: Array &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>面试</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经-JS（二）</title>
    <url>/2024/04/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F-JS(%E4%BA%8C)/</url>
    <content><![CDATA[<h3 id="Q1：-如何判断-JavaScript-的数据类型"><a href="#Q1：-如何判断-JavaScript-的数据类型" class="headerlink" title="Q1： 如何判断 JavaScript 的数据类型"></a>Q1： 如何判断 JavaScript 的数据类型</h3><ol>
<li><p>**<code>typeof()</code> **</p>
<p>使用 <code>typeof</code> 只能判断基本数据类型, 如 number, string, boolean, symbol 和 undefined</p>
<p>对于数组、null、对象来说，其关系错综复杂，使用 typeof 都会统一返回 “object” 字符串。</p>
<p>要想区别对象、数组、函数单纯使用 <code>typeof</code> 是不行的，JavaScript中,通过<code>Object.prototype.toString</code> 方法，判断某个对象值属于哪种内置类型。</p>
</li>
<li><p>**<code>instanceof</code> **</p>
<p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 <code>object</code> 的原型链上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">D</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(o) === C.prototype</span></span><br><span class="line">o <span class="keyword">instanceof</span> D; <span class="comment">// false，因为 D.prototype 不在 o 的原型链上</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果表达式 <code>obj instanceof Foo</code> 返回 <code>true</code>，则并不意味着该表达式会永远返回 <code>true</code>，因为 <code>Foo.prototype</code> 属性的值有可能会改变，改变之后的值很有可能不存在于 <code>obj</code> 的原型链上，这时原表达式的值就会成为 <code>false</code>。</p>
<p><strong>注意:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">//false</span></span><br><span class="line"><span class="title class_">String</span> <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="title class_">Foo</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Foo</span> <span class="keyword">instanceof</span> <span class="title class_">Foo</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong><code>Object.prototype.toString.call()</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">123</span>));    <span class="comment">//[object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;123&#x27;</span>));    <span class="comment">//[object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>));    <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>));    <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;));    <span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]));    <span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));    <span class="comment">//[object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>));    <span class="comment">//[[object Null]]</span></span><br></pre></td></tr></table></figure>

<p>在介绍<code>Object.prototype.toString</code>方法之前，我们先把<code>toString()</code>方法和<code>Object.prototype.toString.call()</code> 方法进行对比。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">//直接对一个数组调用toString()</span></span><br><span class="line">arr.<span class="title function_">toString</span>();<span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="comment">//通过 call 指定 arr 数组为Object.prototype对象中的toString方法的上下文</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr); <span class="comment">//&quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组重写了 <code>toString</code> 方法，所以直接调用数组 <code>arr</code> 上面的 <code>toString</code> 方法调用到的实际是重写后的方法，并不是 <code>Object.prototype</code> 中的 <code>toString</code> 方法。</p>
<p>而重写后的 <code>toString</code> 方法可以把对象转换成字符串，还可以把数值转换成不同进制的数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].<span class="title function_">toString</span>();<span class="comment">// &quot;1,2&quot;  得到字符串</span></span><br><span class="line"></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">2</span>);<span class="comment">//10进制转2进制 1010 ，如果1.toString(2)会报错，因为js会认为.是数字的小数点而不是调用符号</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：</strong> 只有 <code>Object.prototype.toString.call(arr)</code> 可以用来判断数据类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr);	<span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr);		<span class="comment">// &#x27;1,2,3&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>本质：</strong></p>
<p>我们都知道js中的对象都继承自<code>Object</code>，所以当我们在某个对象上调用一个方法时，会先在该对象上进行查找，如果没找到则会进入对象的原型（也就是 <code>.prototype</code> ）进行查找，如果没找到，同样的也会进入对象原型的原型进行查找，直到找到或者进入原型链的顶端 <code>Object.prototype</code> 才会停止。</p>
<p>所以，当我们使用 <code>arr.toString()</code> 时，不能进行复杂数据类型的判断，因为它调用的是<code>Array.prototype.toString</code>，虽然<code>Array</code>也继承自<code>Object</code>，但js在<code>Array.prototype</code>上重写了<code>toString</code>，而我们通过 <code>toString.call(arr)</code> 实际上是通过原型链调用了 <code>Object.prototype.toString</code> 。</p>
</li>
</ol>
<h3 id="Q2：如何理解ES6中的-this"><a href="#Q2：如何理解ES6中的-this" class="headerlink" title="* Q2：如何理解ES6中的 this"></a>* Q2：如何理解ES6中的 <code>this</code></h3><p>我们常见的window属性和方法有 <code>alter</code>，<code>document</code>，<code>parseInt</code>，<code>setTimeout</code>，<code>setInterval</code>，<code>localtion</code> 等等，这些在默认的情况下是省略了window前缀的。（window.alter &#x3D; alter）。</p>
<ol>
<li><p>普通函数中的this</p>
<blockquote>
<p>this 永远指向 <strong>调用</strong> 包含 自己（this本身） 的 <strong>函数</strong> 对应的对象。</p>
</blockquote>
<p>也就是说，包含 this 的函数 只在乎是谁调用了它，跟在哪里进行的函数声明没有关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>函数在最外层直接运行，因为 <code>test()</code> 是被window对象调用的，所以这里的 <code>this.a</code> 对应的应该是<strong>全局变量（或者叫window变量）</strong>, 而不是test函数里的局部变量，由于在 window 对象中没有声明变量a，所以输出 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">&#x27;America&#x27;</span>,</span><br><span class="line">    show : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">show</span>(); <span class="comment">// America</span></span><br></pre></td></tr></table></figure>

<p>另一个题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">&#x27;America&#x27;</span>,</span><br><span class="line">    show : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = obj.<span class="title function_">show</span>(); <span class="comment">//运行了，返回了一个函数</span></span><br><span class="line"><span class="title function_">a</span>(); <span class="comment">// China</span></span><br></pre></td></tr></table></figure>

<p>此时， <code>a</code> 等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<ol>
<li><p>在一般函数方法中使用 this 指代全局对象</p>
</li>
<li><p>作为对象方法调用，this 指代上级对象</p>
</li>
</ol>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line">obj.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>作为构造函数调用，this 指向 new 出的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123; <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;China&#x27;</span>; &#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="property">name</span>); <span class="comment">//&#x27;China&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>apply, call 调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">name</span>);<span class="comment">// &#x27;animal&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>箭头函数中的this <strong>(还没搞懂)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">   <span class="attr">sayHello</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="title function_">sayHello</span>();<span class="comment">// 还是以为输出A ? 错啦，其实输出的是window</span></span><br></pre></td></tr></table></figure>

<p>箭头函数没有自己的this值，箭头函数中所使用的this来自于函数作用域链。</p>
<p>代码没有在任何函数中执行，而是在全局作用域中执行时，this的值就是global对象，对于浏览器来说，this就是window。</p>
<p>事实上, 箭头函数并不绑定 <code>this</code>、<code>arguments</code>、<code>super(ES6)</code>、抑或 <code>new.target(ES6)</code> 箭头函数不会绑定这些局部变量，这意味着所有涉及它们的引用，都会沿袭向上查找外层作用域链的方案来处理。</p>
<table>
<thead>
<tr>
<th><a href="https://blog.csdn.net/devincob/article/details/72628757">javascript中的关键字this_箭头函数中的this为什么不可以更改-CSDN博客</a></th>
</tr>
</thead>
</table>
</li>
</ol>
<h3 id="Q3：JS内置对象及方法"><a href="#Q3：JS内置对象及方法" class="headerlink" title="Q3：JS内置对象及方法"></a>Q3：JS内置对象及方法</h3><h4 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h4><ol>
<li><p>length </p>
</li>
<li><p><strong><code>join</code>:</strong> 将数组装换成字符串, 返回一个字符串</p>
</li>
<li><p>reverse</p>
</li>
<li><p><strong><code>delete</code></strong> </p>
</li>
<li><p>shift, pop, unshift, push</p>
</li>
<li><p><code>concat</code> 连接数组</p>
</li>
<li><p><code>slice</code> 截取数组, 返回数组的一部分, 原数组不会改变</p>
</li>
<li><p>sort</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span> <span class="number">4</span>, <span class="number">5</span>,]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b <span class="comment">// 从小到大</span></span><br><span class="line">    <span class="comment">// return b-a // 从大到小</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>splice</code> 插入, 删除, 替换</p>
</li>
<li><p><code>toLacaleString</code> 把数组转换成局部字符串</p>
</li>
<li><p>toString 返回字符串</p>
</li>
<li><p>foEach</p>
</li>
<li><p><code>every</code> : 判断所有元素是否都符合要求</p>
</li>
<li><p><code>map</code> 对元素进行重新组装形成新数组</p>
</li>
<li><p><code>filter</code> 过滤元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span> <span class="number">4</span>, <span class="number">5</span>,]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index</span>)&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经-Vue(三)</title>
    <url>/2024/04/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F-Vue(%E4%B8%89)/</url>
    <content><![CDATA[<h2 id="WebAPI（Vue）"><a href="#WebAPI（Vue）" class="headerlink" title="WebAPI（Vue）"></a>WebAPI（Vue）</h2><h3 id="set"><a href="#set" class="headerlink" title="$set"></a><code>$set</code></h3><p>设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法用于避开Vue不能检测属性被添加的限制。</p>
<p><strong>常见问题：</strong> <em>数据更新了页面还没更新是为什么？</em> </p>
<p>有可能是以下问题：</p>
<ol>
<li><p><em>Vue 无法检测实例被创建时不存在于 <code>data</code> 中的 property</em></p>
<p>由于 Vue 会在初始化实例时对 property 执行 <code>getter/setter</code> 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。</p>
</li>
<li><p><em>Vue 无法检测对象 property 的添加或移除</em></p>
<p>由于 JavaScript（ES5） 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 <code>getter/setter</code>，所以属性必须在 <code>data</code> 对象上才能让 Vue.js 转换它，才能让它是响应的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态添加 - vm.$set</span></span><br><span class="line">vm.$set(vm.<span class="property">obj</span>, propertyName, newValue)</span><br><span class="line"><span class="comment">// 动态添加多个 </span></span><br><span class="line"><span class="comment">// 代替 `Object.assign(this.obj, &#123; a: 1, b: 2 &#125;)`</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">obj</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">obj</span>, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>Vue 不能检测利用数组索引直接修改一个数组项</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">items</span>[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(vm.<span class="property">items</span>, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vm.$set</span></span><br><span class="line">vm.$set(vm.<span class="property">items</span>, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>在异步更新执行之前操作 DOM 数据不会变化</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example&quot;</span>&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">message</span> = <span class="string">&#x27;new message&#x27;</span> <span class="comment">// 更改数据</span></span><br><span class="line">vm.<span class="property">$el</span>.<span class="property">textContent</span> === <span class="string">&#x27;new message&#x27;</span> <span class="comment">// false</span></span><br><span class="line">vm.<span class="property">$el</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span> <span class="comment">// 页面没有变化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">message</span> = <span class="string">&#x27;new message&#x27;</span> <span class="comment">// 更改数据</span></span><br><span class="line"><span class="comment">//使用 Vue.nextTick(callback) callback 将在 DOM 更新完成后被调用</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  vm.<span class="property">$el</span>.<span class="property">textContent</span> === <span class="string">&#x27;new message&#x27;</span> <span class="comment">// true</span></span><br><span class="line">  vm.<span class="property">$el</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span> <span class="comment">// 文字颜色变成红色</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>!!!拓展：</strong> <em>Object.defineProperty() 可以监测数组的变化</em>  &#x3D;&#x3D;<strong>(Vue2响应式的原理)</strong>&#x3D;&#x3D;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index</span>) &#123;</span><br><span class="line">    </span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(arr, index, &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发 setter&#x27;</span>)</span><br><span class="line">      item = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发 getter&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;123&#x27;</span>  <span class="comment">// 触发 setter</span></span><br><span class="line">arr[<span class="number">1</span>]          <span class="comment">// 触发 getter 返回值为 &quot;123&quot;</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">5</span>      <span class="comment">// 不会触发 setter 和 getter</span></span><br></pre></td></tr></table></figure>

<p><code>Vue3</code> 中, <code>Proxy</code> 替代 <code>defineProperty</code> 实现响应式</p>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a><code>$nextTick</code></h3><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。所以就衍生出了这个<strong>获取更新后的DOM的Vue方法</strong>。所以<strong>放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js</strong>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="attr">testClick</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> that=<span class="variable language_">this</span>;</span><br><span class="line">    that.<span class="property">testMsg</span>=<span class="string">&quot;修改后的值&quot;</span>;</span><br><span class="line">    that.$nextTick(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">$refs</span>.<span class="property">aa</span>.<span class="property">innerText</span>);  <span class="comment">//输出：修改后的值</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="el"><a href="#el" class="headerlink" title="$el"></a>$el</h3><p><code>this</code>指向组件实例，<code>$el</code>用于获取<code>Vue</code>实例挂载的<code>DOM</code>元素，在<code>mounted</code>之后的生命周期中才有效，之前的钩子函数内无效。（跟生命周期各个阶段的行为有关，<code>mounted</code>之前没有DOM）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">    &lt;h1 @click=&quot;fn()&quot;&gt;</span><br><span class="line">      Lorem, ipsum</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    // this.$el只在mounted中才有效</span><br><span class="line">    console.log(&#x27;this:&#x27;, this) // 打印this指向组件实例。</span><br><span class="line">    console.log(&#x27;this.$el:&#x27;, this.$el) // 打印这个vue组件的dom对象</span><br><span class="line">    this.$el.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn () &#123;</span><br><span class="line">      console.log(&#x27;test_this.$el:&#x27;, this.$el) // &lt;div id=&quot;root&quot;&gt;...&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="refs"><a href="#refs" class="headerlink" title="$refs()"></a>$refs()</h3><p> $refs 是一个对象，持有已注册过 ref 的所有的子组件。</p>
<p><strong>区别于 Vue3 <code>ref()方法</code>，ref()用于实现响应式数据</strong></p>
<h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><ol>
<li><code>$data</code> 获取当前日期</li>
<li><code>$children</code> 获取子组件, 返回一个数组</li>
<li><code>$root</code>  获取根组件</li>
<li><code>$parent</code> 获取父组件</li>
</ol>
<h3 id="data-定义数据"><a href="#data-定义数据" class="headerlink" title="data() 定义数据"></a>data() 定义数据</h3><ol>
<li><code>data</code> 是Vue的文件对象：</li>
</ol>
<ul>
<li><p>类型：Object | Function</p>
</li>
<li><p>限制：组件的定义只接受 function</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;myComponent&quot;</span>,&#123;</span><br><span class="line">	<span class="attr">props</span>: [],</span><br><span class="line">	<span class="attr">data</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">newTodoText</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">			<span class="attr">visitCount</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">hideCompleteTodos</span>: <span class="literal">false</span>,</span><br><span class="line">			<span class="attr">todos</span>: [],</span><br><span class="line">			<span class="attr">error</span>: <span class="literal">null</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>Vue实例的数据对象，<strong>Vue</strong>将会递归将data的属性转换为<code>getter/setter</code>，从而让data的属性能够响应数据变化。</p>
<p>对象必须是纯粹的对象（含有零个或多个的key&#x2F;value对）：浏览器API创建的原生对象，原型上的属性会被忽略。大概来说，data应该只能是数据，不推荐观察拥有状态行为的对象。</p>
<p>一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vue</span> = &#123; </span><br><span class="line">	<span class="attr">_newTodoText</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">newTodoText</span>()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_newTodoText</span>;</span><br><span class="line">	&#125;.</span><br><span class="line">	<span class="keyword">set</span> <span class="title function_">newTodoText</span>(<span class="params">value</span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">_newTodoText</span> = vlaue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。<strong>Vue</strong>实例也代理了<strong>data</strong>对象上所有的属性，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code> </p>
<p>以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 <code>Vue</code> 实例代理，因为它们可能和<strong>Vue</strong>内置的属性、<strong>API</strong>方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p>
</li>
<li><p>当一个<strong>组件</strong>被定义，<code>data</code> 必须声明为 <em>返回</em> 一个初始数据对象的函数. 为什么组件（component）里定义的 <code>data</code> 必须是方法类型，原因是<strong>组件就是一个可复用的vue的实例。</strong>这也就意味着如果你的data是一个普通的对象，那么所有复用这个实例的组件都将引用同一份数据，这就造成了<strong>数据污染</strong><br>我们将 <code>data</code> 封装成一个函数，我们在实例化组件的时候只是调用了这个函数生成的数据副本，这就避免了数据污染。</p>
</li>
<li><p>为什么在大型项目中 <code>data</code> 需要使用return返回数据呢？</p>
<p>答：不使用 <code>return</code> 包裹的数据会在项目的全局可见，会造成变量污染；使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。</p>
</li>
</ol>
<h3 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h3><p>在 Vue 3 中，计算属性（Computed Properties）允许你声明一个依赖于其他响应式数据属性的属性，并且这个属性的值会根据其依赖的数据的变化而自动更新。计算属性是基于它们的依赖关系进行缓存的，只有在它的相关依赖发生改变时才会重新求值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>原始值：&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计算后的值：&#123;&#123; reversedMessage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;message = &#x27;Hello World!&#x27;&quot;</span>&gt;</span>修改原始值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello Vue3&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> reversedMessage = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> message.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      message,</span></span><br><span class="line"><span class="language-javascript">      reversedMessage</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Vue 3 中，计算属性不仅仅是一个简单的计算结果的缓存，它们还允许你定义一个 setter 函数，该函数会在你尝试修改计算属性的值时触发。这为你提供了一种方式来观察或拦截对计算属性的更改。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedValue = <span class="title function_">computed</span>(&#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> baseValue.<span class="property">value</span> * <span class="number">2</span>; <span class="comment">// Getter</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        baseValue.<span class="property">value</span> = newValue / <span class="number">2</span>; <span class="comment">// Setter</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">incrementComputedValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 直接修改计算属性的值会触发 setter</span></span><br><span class="line">      computedValue.<span class="property">value</span> += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> <code>computed</code> 中的 <code>this</code> 指向 vm 实例</p>
<h3 id="computed-和-data-可以重名吗"><a href="#computed-和-data-可以重名吗" class="headerlink" title="computed 和 data 可以重名吗?"></a><code>computed</code> 和 <code>data</code> 可以重名吗?</h3><p>由于 <code>computed</code>, <code>data</code>, 和 <code>props</code> 都是挂载在Vue实例上的,所以不能重名.</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ol>
<li><p>基本用法</p>
<p><code>watch</code> 是vue内部提供的一个用于侦听功能的更通用的方法，其用来响应数据的变化，通过特定的数据变化驱动一些操作。vue官方文档解释当需要在数据变化时执行异步或开销较大的操作时，推荐使用该方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">		<span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="attr">variable</span>:<span class="literal">null</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">watch</span>:&#123;</span><br><span class="line">			<span class="comment">// 此处监听variable变量，当期有变化时执行</span></span><br><span class="line">			<span class="title function_">variable</span>(<span class="params">item1,item2</span>)&#123;</span><br><span class="line">				<span class="comment">// item1为新值，item2为旧值</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// variable:&#123;</span></span><br><span class="line">			<span class="comment">//	// 此处监听variable变量，当期有变化时执行</span></span><br><span class="line">			<span class="comment">//	handler(item1,item2)&#123;</span></span><br><span class="line">			<span class="comment">//		// item1为新值，item2为旧值</span></span><br><span class="line">			<span class="comment">//	&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>immediate</code> 用法</p>
<p>当未设置 <code>immediate</code> 或者 <code>immediate</code> 的值为 <code>false</code> 时，被侦听的变量在页面初次加载时第一次绑定值的时候，并不会执行监听操作；但是当设置了 <code>immediate</code> 的值为 <code>true</code> 时，则会立刻执行一次监听操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">			<span class="comment">// 此处监听variable变量，当期有变化时执行</span></span><br><span class="line">			<span class="title function_">variable</span>(<span class="params">item1,item2</span>)&#123;</span><br><span class="line">				<span class="comment">// item1为新值，item2为旧值</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">immediate</span>:<span class="literal">true</span> <span class="comment">// watch侦听操作内的函数会立刻被执行</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>deep深度监听</p>
<p><em>侦听普通变量的变化</em>是使用以上方法，当侦听的某个变量值是对象时则不起作用，这时需要使用deep深度监听。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">		<span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="attr">obj</span>:&#123;</span><br><span class="line">				<span class="attr">a</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">				<span class="attr">b</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">				<span class="attr">c</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">watch</span>:&#123;</span><br><span class="line">			<span class="attr">obj</span>:&#123;</span><br><span class="line">				<span class="comment">// 此处监听obj属性a值变量</span></span><br><span class="line">				<span class="title function_">handler</span>(<span class="params">item1,item2</span>)&#123;</span><br><span class="line">					<span class="comment">// item1为新值，item2为旧值</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">deep</span>:<span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>数组（一维、多维）的变化不需要深度监听，对象数组中对象的属性变化则需要deep深度监听</p>
<p><em>对象属性变化</em></p>
<p>对象内某个属性产生变化，直接监听该对象是监测不到变化的，只能监听该对象的属性变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="attr">newObj</span>:&#123;</span><br><span class="line">				<span class="attr">a</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">				<span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">watch</span>:&#123;</span><br><span class="line">			<span class="string">&#x27;newObj.a&#x27;</span>(val)&#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p><em>数组对象中对象属性变化</em></p>
<p>数组对象中对象属性变化监测需要使用deep:true，多少层内产生变化都可以监测到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="attr">newArr</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">list</span>:[</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="attr">label</span>:<span class="literal">null</span></span><br><span class="line">						&#125;</span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">methods</span>:&#123;</span><br><span class="line">			<span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">				<span class="variable language_">this</span>.<span class="property">newArr</span>[<span class="number">0</span>].<span class="property">list</span>[<span class="number">0</span>].<span class="property">label</span> = <span class="string">&quot;2020年11月10日10:36:58&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">watch</span>:&#123;</span><br><span class="line">			<span class="attr">newArr</span>:&#123;</span><br><span class="line">				<span class="title function_">handler</span>(<span class="params">val</span>)&#123;</span><br><span class="line">					<span class="comment">// ...</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">deep</span>:<span class="literal">true</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://blog.csdn.net/weixin_41993525/article/details/109492837">https://blog.csdn.net/weixin_41993525/article/details/109492837</a></p>
</li>
</ol>
<h3 id="method与computed"><a href="#method与computed" class="headerlink" title="method与computed"></a>method与computed</h3><ol>
<li>Computed</li>
</ol>
<p>​    Computed 是一种以声明式的方式处理数据的方式。可以通过在 Vue 实例中定义 <code>computed</code> 属性 <em>(Vue2)<em>或在组件中使用 <code>computed</code> 选项 <em>(Vue3)</em> 来创建</em>计算属性</em>。</p>
<p>计算属性是根据依赖的数据进行缓存的，只有当依赖的数据发生变化时，计算属性才会重新计算。这样可以避免不必要的重复计算，提高性能。</p>
<p>Computed 的使用场景包括：</p>
<ul>
<li>数据衍生：当需要根据已有数据计算出新的数据时，可以使用计算属性。例如，根据商品的价格和数量计算出总价。</li>
<li>数据过滤和转换：当需要对数据进行过滤、格式化或转换时，可以使用计算属性。例如，将日期格式化为特定的显示格式。</li>
</ul>
<p>需要注意的是，计算属性只会在依赖的数据发生变化时才重新计算，因此适用于那些相对稳定的数据计算场景。</p>
<ol start="2">
<li><p>Methods</p>
<p>Methods 是一种以命令式的方式处理数据的方式。你可以在 Vue 实例中定义 methods 属性或在组件中使用 methods 选项来创建方法。 方法可以接受参数，并根据参数进行相应的操作。每次调用方法时，都会执行其中的代码并返回结果。</p>
</li>
</ol>
<p>Methods 的使用场景包括：</p>
<ul>
<li>事件处理：当需要处理用户交互事件时，可以使用方法。例如，点击按钮时执行特定的操作。</li>
<li>复杂逻辑：当需要执行复杂的业务逻辑，或者需要进行条件判断和循环操作时，可以使用方法。</li>
</ul>
<p>需要注意的是，每次调用方法时，都会执行其中的代码，不会进行缓存。因此，如果方法中包含复杂的计算逻辑或者涉及频繁调用的场景，可能会对性能产生影响。</p>
<ol start="3">
<li><code>Computed</code> 和 <code>Methods</code> 的区别</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Computed</th>
<th>Methods</th>
</tr>
</thead>
<tbody><tr>
<td>缓存机制</td>
<td>具有缓存机制，只有在依赖数据变化时才重新计算</td>
<td>每次调用都会执行其中的代码</td>
</tr>
<tr>
<td>使用场景</td>
<td>适用于根据已有数据衍生新的数据和数据过滤&#x2F;转换场景，并具有缓存机制提高性能</td>
<td>适用于处理事件和复杂逻辑的场景</td>
</tr>
<tr>
<td>加载顺序</td>
<td>HTML DOM加载后马上执行, 混入Vue实例中</td>
<td>在调用后才执行, 不调用不执行</td>
</tr>
<tr>
<td>加载时</td>
<td>compted 当数据没有改变时是直接从缓存里取数据</td>
<td>methods每次都需要执行获得结果</td>
</tr>
</tbody></table>
<p><strong>注意:</strong> </p>
<p>**默认情况: **<code>computed</code> 在DOM加载后马上执行,  <code>watch</code> 在 <code>computed</code> 执后执行, 而<code>Methods</code> 默认不执行.  </p>
<p><strong>触发某一事件：</strong> 先 <code>computed</code> 后 <code>methods</code> 最后才是 <code>watch</code>, 原因是 <code>computed</code> 是基于缓存加载的.</p>
<hr>
<table>
<thead>
<tr>
<th>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br/>原文链接：<a href="https://blog.csdn.net/m0_58013334/article/details/132381524">https://blog.csdn.net/m0_58013334/article/details/132381524</a></th>
</tr>
</thead>
</table>
<h2 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h2><p>12个常见指令，顺序如下：v-on、v-bind、v-model、v-for、v-show、v-if、v-else&#x2F;v-else-if、v-text、 v-html、v-cloak、v-once、v-pre</p>
<ol>
<li><p><code>v-on</code></p>
<p><em>用于绑定事件</em>, 语法糖 <code>@</code>, 参数为 @click(arg1, arg2 …, event)</p>
<p><em>绑定单个</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;ShowInfo&quot;</span>&gt;</span>鼠标单击事件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>常用事件: </p>
<p>键盘事件: keyup(释放), keyDown(按下), keypress(除 shift, Fn, CapsLock外的连续触发)</p>
<p>表单事件：reset(重置), submit(提交)，input(用于实时查询), blur(失去焦点)</p>
<p><em>绑定多个事件:</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123;click:single,dblclick:double&#125;&quot;</span>&gt;</span>单击n+1,双击m-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>v-bind</code></p>
<p>单向数据绑定，它是为标签里的某个属性绑定值用的</p>
<p><code>v-bind:</code>可以简写为 “<code>:</code>“ :herf&#x3D;’xxx’</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">  单向数据绑定：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>v-model</p>
<p>双向数据绑定，v-model只能应用在表单类元素（如：input、select等）</p>
<p><code>v-model:value</code> 可以简写为 <code>v-model</code>，因为v-model默认收集的就是value值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">   双向数据绑定：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model:value</span>=<span class="string">&quot;aname&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 下边一行代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;h2 v-model:x=&quot;name&quot;&gt;你好啊&lt;/h2&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>v-for</p>
<p><em>数组遍历</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">&quot;(i,index) in arr&quot;</span>&gt;</span>每一项：&#123;&#123;i&#125;&#125;--索引值：&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>对象遍历</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">&quot;(i,index) in arr&quot;</span>&gt;</span>键：&#123;&#123;i&#125;&#125;--值：&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>迭代数字</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">&quot;(i,index) in 6&quot;</span>&gt;</span>每一项：&#123;&#123;i&#125;&#125;--索引：&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>v-show</p>
<p>条件渲染，<code>v-show</code>指令通过改变元素的 css 属性（display）来决定元素是显示还是隐藏。<code>v-show</code>等于false时,相当于设置了样式的display为none</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-show</span>=<span class="string">&quot;showTest&quot;</span>&gt;</span>v-show = true,故这个元素显示出来了<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>v-if, v-else&#x2F;v-else-if</p>
<p>条件渲染，与<code>v-show</code>类似，唯一不同的是，当<code>v-if = false</code>的时候，直接删掉DOM结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;ifTest&quot;</span>&gt;</span>v-if = true,故这个元素显示出来了<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>v-if</code> 和 <code>v-show</code> 的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>v-if</th>
<th>v-show</th>
</tr>
</thead>
<tbody><tr>
<td>隐藏原理</td>
<td>删掉DOM节点结构达到隐藏元素的目的</td>
<td>通过设定 disploy: none; 设置节点不显示</td>
</tr>
<tr>
<td>性能</td>
<td>由于含有多次的添加、删除节点操作，性能较差</td>
<td>只加载一次结构，之后通过CSS设置隐藏，性能较好</td>
</tr>
</tbody></table>
</li>
<li><p>为什么要避免 <code>v-for</code> 和 <code>v-if</code> 的同时出现</p>
<p> 因为v-for的优先级比v-if 的优先级高，所以每次渲染时都会先循环再进行条件判断，而又因为v-if 会根据渲染条件为true 或false来决定渲染与否的，所以如果将v-if 和v-for用在一起会特别消耗性能</p>
<p><strong>解决方法:</strong></p>
<ol>
<li>将v-if 放在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for 循环</li>
<li>如果条件出现在循环内部，不得不放在一起，可通过计算属性computed提前过滤掉那些不需要显示的项</li>
</ol>
</li>
<li><p>v-text</p>
<p>用于将数据填充到标签中，作用于插值语法表达式类似，但是没有闪动问题 （如果数据中有HTML标签会将html标签一并输出 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">&quot;str&quot;</span>&gt;</span>公众号:<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li>v-text会把解析到为文本<strong>完全替换掉</strong>标签里的内容</li>
<li>不能解析字符串，v-text会把所有的字符串都当成正常的文本解析，不会当成标签，即使你的data里的str数据中有标签结构</li>
</ol>
</li>
<li><p>v-html</p>
<p>v-html和v-text的区别：它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</p>
<p><strong>严重注意：v-html有安全性问题！！！</strong></p>
<ol>
<li><p>在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p>
</li>
<li><p>一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p>
</li>
</ol>
</li>
<li><p>v-cloak</p>
<p>防止闪烁,本质是一个<strong>特殊属性</strong>，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。使用css配合v-cloak可以解决<strong>网速慢</strong>时页面展示出的问题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-cloak<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">   <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line"><span class="language-css">     <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">   &#125;</span></span><br><span class="line"><span class="language-css"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">name</span>:<span class="string">&quot;Dapan&quot;</span></span></span><br><span class="line"><span class="language-javascript">     &#125;,</span></span><br><span class="line"><span class="language-javascript">   &#125;);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>v-once</p>
<p>v-once所在节点在初次动态渲染后，就视为<strong>静态内容</strong>了。以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-once</span>&gt;</span>初始化时候的n是:&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>现在的n是:&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;n++&quot;</span>&gt;</span>点我n加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>v-pre</p>
<p>跳过Vue在有<code>v-pre</code>属性的所在节点的编译过程。可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会<strong>加快编译速度</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-pre</span>&gt;</span>没有使用指令语法和插值语法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">name</span>: <span class="string">&#x27;dapan&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<table>
<thead>
<tr>
<th>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br/>原文链接：<a href="https://zhuanlan.zhihu.com/p/483838000">https://zhuanlan.zhihu.com/p/483838000</a></th>
</tr>
</thead>
</table>
<h2 id="Vue修饰符"><a href="#Vue修饰符" class="headerlink" title="Vue修饰符"></a>Vue修饰符</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>WebAPI</tag>
        <tag>Vue指令</tag>
      </tags>
  </entry>
  <entry>
    <title>医学图像处理（三）</title>
    <url>/2024/04/24/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>医学图像处理</tag>
        <tag>计算机视觉</tag>
        <tag>计算机图像处理</tag>
        <tag>毕业设计</tag>
      </tags>
  </entry>
  <entry>
    <title>医学图像处理（二）</title>
    <url>/2024/04/24/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>医学图像处理</tag>
        <tag>计算机视觉</tag>
        <tag>计算机图像处理</tag>
        <tag>毕业设计</tag>
      </tags>
  </entry>
  <entry>
    <title>医学图像处理（一）</title>
    <url>/2024/04/24/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Part-1-Basic-Concepts-基本概念"><a href="#Part-1-Basic-Concepts-基本概念" class="headerlink" title="Part 1:Basic Concepts 基本概念"></a>Part 1:Basic Concepts 基本概念</h1><h2 id="Histogram-and-Threshold-Binary-Operation"><a href="#Histogram-and-Threshold-Binary-Operation" class="headerlink" title="Histogram and Threshold;Binary Operation"></a>Histogram and Threshold;Binary Operation</h2><h2 id="直方图和阈值；二进制运算"><a href="#直方图和阈值；二进制运算" class="headerlink" title="直方图和阈值；二进制运算"></a>直方图和阈值；二进制运算</h2><h2 id="Convolution-Correlation"><a href="#Convolution-Correlation" class="headerlink" title="Convolution: Correlation"></a>Convolution: Correlation</h2><h2 id="卷积：相关性"><a href="#卷积：相关性" class="headerlink" title="卷积：相关性"></a>卷积：相关性</h2><h2 id="Basic-Image-Operations-Region-Property"><a href="#Basic-Image-Operations-Region-Property" class="headerlink" title="Basic Image Operations;Region Property"></a>Basic Image Operations;Region Property</h2><h2 id="基本图像操作；区域属性"><a href="#基本图像操作；区域属性" class="headerlink" title="基本图像操作；区域属性"></a>基本图像操作；区域属性</h2><h2 id="VTK-and-ITK"><a href="#VTK-and-ITK" class="headerlink" title="VTK and ITK"></a>VTK and ITK</h2><h1 id="Part-2-Mathematical-Morphology"><a href="#Part-2-Mathematical-Morphology" class="headerlink" title="Part 2:Mathematical Morphology"></a>Part 2:Mathematical Morphology</h1><h2 id="数学形态"><a href="#数学形态" class="headerlink" title="数学形态"></a>数学形态</h2><h2 id="Binary-Morphology"><a href="#Binary-Morphology" class="headerlink" title="Binary Morphology"></a>Binary Morphology</h2><h2 id="二元形态"><a href="#二元形态" class="headerlink" title="二元形态"></a>二元形态</h2><h2 id="Grayscale-Morphology"><a href="#Grayscale-Morphology" class="headerlink" title="Grayscale Morphology"></a>Grayscale Morphology</h2><h2 id="灰度形态"><a href="#灰度形态" class="headerlink" title="灰度形态"></a>灰度形态</h2>]]></content>
      <tags>
        <tag>医学图像处理</tag>
        <tag>计算机视觉</tag>
        <tag>计算机图像处理</tag>
        <tag>毕业设计</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（一）</title>
    <url>/2024/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>链表</tag>
        <tag>集合</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（三）</title>
    <url>/2024/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)%20/</url>
    <content><![CDATA[<h3 id="图的简介"><a href="#图的简介" class="headerlink" title="图的简介"></a>图的简介</h3><p>图用于表示任何二元关系</p>
<p>JS中没有图，但可以用 <code>Object</code> 和 <code>Array</code> 构建图</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> graph</span><br><span class="line">	<span class="number">0</span>:[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">	<span class="number">1</span>:[<span class="number">2</span>],</span><br><span class="line">	<span class="number">2</span>:[<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line">	<span class="number">3</span>:[<span class="number">3</span>]<span class="number">1</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><p>图的表示方法：邻接矩阵，邻接表，关联矩阵</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><h3 id="DFS和BFS"><a href="#DFS和BFS" class="headerlink" title="DFS和BFS"></a>DFS和BFS</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>思路：1. 访问根节点。 2. 深度优先访问根节点的未访问的相邻节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="built_in">require</span>(./graph);</span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">const</span> dfs (n)=&gt;&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">	visited.<span class="title function_">add</span>(n);</span><br><span class="line">	graph[n].<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited.<span class="title function_">has</span>(c))  <span class="title function_">dfs</span>(c);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>思路：1. 新建一个队列，将根节点入队。 2. 出队一个节点，然后把未访问过的相邻节点入队。 3. 重复步骤直到队为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="built_in">require</span>(./graph);</span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bfs</span> = n =&gt; &#123;</span><br><span class="line">    list.<span class="title function_">push</span>(n)</span><br><span class="line">    visited.<span class="title function_">add</span>(n)</span><br><span class="line">    <span class="keyword">while</span> (list.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = list.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">        graph[x].<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(c)) &#123;</span><br><span class="line">                list.<span class="title function_">push</span>(c)</span><br><span class="line">                visited.<span class="title function_">add</span>(c)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><ol>
<li>65：有效数字</li>
<li>417：太平洋大西洋水流问题</li>
<li>133：克隆图</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(二)</title>
    <url>/2024/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法（一）</title>
    <url>/2024/04/24/%E7%AE%97%E6%B3%95(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><ul>
<li>思路：<ol>
<li>从数组的第一个元素开始。</li>
<li>逐个检查每个元素，直到找到目标元素或遍历完整个数组。</li>
</ol>
</li>
<li>注意点：简单但效率低，适用于小数组或数据分布不均匀的情况。</li>
</ul>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><ul>
<li><p>思路：</p>
<ol>
<li><p>在有序数组中，找到中间的元素。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);<span class="string">` </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较中间元素与目标元素。</p>
</li>
<li><p>如果中间元素等于目标元素，则查找成功。</p>
</li>
<li><p>如果中间元素小于目标元素，则在右半部分递归查找。</p>
</li>
<li><p>如果中间元素大于目标元素，则在左半部分递归查找。</p>
</li>
</ol>
</li>
<li><p>注意点：数组必须是有序的，适用于大数据量且有序的情况。</p>
</li>
</ul>
<h4 id="哈希查找"><a href="#哈希查找" class="headerlink" title="* 哈希查找"></a>* 哈希查找</h4><ul>
<li><p>思路：</p>
<ol>
<li>使用哈希函数将键映射到哈希表的索引。</li>
<li>直接访问该索引位置查找元素。</li>
</ol>
</li>
<li><p>注意点：哈希函数的设计和冲突解决策略对性能至关重要，适用于快速查找且内存空间允许的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义哈希表类HashTable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="comment">// 构造函数，初始化哈希表</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">size = <span class="number">42</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个指定大小的数组，用于存储哈希桶</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">buckets</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(size);</span><br><span class="line">    <span class="comment">// 保存哈希表的大小</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 哈希函数，将键转换成哈希桶索引</span></span><br><span class="line">  <span class="title function_">hash</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用键的字符串表示的长度进行模运算，得到索引值</span></span><br><span class="line">    <span class="keyword">return</span> key.<span class="title function_">toString</span>().<span class="property">length</span> % <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置键值对</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算键的哈希值</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="comment">// 如果当前索引的桶为空，初始化为一个空数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">buckets</span>[index]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">buckets</span>[index] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将键值对添加到对应的桶中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">buckets</span>[index].<span class="title function_">push</span>([key, value]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取键对应的值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算键的哈希值</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="comment">// 如果对应桶不存在，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">buckets</span>[index]) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历桶中的元素，寻找匹配的键</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">buckets</span>[index]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k === key) &#123;</span><br><span class="line">        <span class="comment">// 如果找到匹配的键，返回对应的值</span></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈希表实例</span></span><br><span class="line"><span class="keyword">let</span> hashTable = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line"><span class="comment">// 在哈希表中设置键为&#x27;name&#x27;的值为&#x27;John&#x27;</span></span><br><span class="line">hashTable.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="comment">// 在哈希表中设置键为&#x27;age&#x27;的值为25</span></span><br><span class="line">hashTable.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 打印出键&#x27;name&#x27;对应的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashTable.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// John</span></span><br><span class="line"><span class="comment">// 打印出键&#x27;age&#x27;对应的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashTable.<span class="title function_">get</span>(<span class="string">&#x27;age&#x27;</span>)); <span class="comment">// 25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="二叉搜索树（BST）查找"><a href="#二叉搜索树（BST）查找" class="headerlink" title="二叉搜索树（BST）查找"></a>二叉搜索树（BST）查找</h4><ul>
<li>思路：<ol>
<li>从树的根节点开始。</li>
<li>比较当前节点的值与目标值。</li>
<li>如果当前节点的值等于目标值，查找成功。</li>
<li>如果目标值小于当前节点的值，则在左子树中递归查找。</li>
<li>如果目标值大于当前节点的值，则在右子树中递归查找。</li>
</ol>
</li>
<li>注意点：树的结构对查找效率有重要影响，平衡树（如AVL树、红黑树）可以提供更稳定的性能。</li>
</ul>
<h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><ul>
<li>思路：与二叉搜索树查找类似，但在红黑树中，节点还包含了颜色信息，用于维护树的平衡。</li>
<li>注意点：红黑树的自平衡特性保证了查找、插入和删除的最坏情况时间复杂度为O(log n)。</li>
</ul>
<h4 id="平衡查找树（AVL树）查找"><a href="#平衡查找树（AVL树）查找" class="headerlink" title="平衡查找树（AVL树）查找"></a>平衡查找树（AVL树）查找</h4><ul>
<li><p>思路：与二叉搜索树查找类似，但在AVL树中，每个节点的左右子树的高度差不超过1。</p>
</li>
<li><p>注意点：AVL树的高度平衡保证了查找效率的稳定。</p>
</li>
<li></li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li>思路：<ol>
<li>从数组的第一个元素开始，比较相邻元素。</li>
<li>如果顺序错误，则交换它们的位置。</li>
<li>每轮遍历后，最大的元素会被移动到数组的末尾。</li>
<li>重复上述步骤，直到整个数组有序。</li>
</ol>
</li>
<li>注意点：简单但效率低，适用于小数组。</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>思路：<ol>
<li>选择一个基准元素。</li>
<li>将数组分为小于和大于基准的两部分。</li>
<li>递归地对这两部分进行快速排序。</li>
</ol>
</li>
<li>注意点：基准元素的选择和数组的分割方式对性能有重要影响，适用于大数据量。</li>
</ul>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul>
<li><p>思路：</p>
<ol>
<li>从数组的第二个元素开始，将其与前面的元素比较。</li>
<li>如果前面的元素大于当前元素，则将前面的元素向后移动一位。</li>
<li>重复上述步骤，直到当前元素找到合适的位置。</li>
<li>逐步将未排序的元素插入到已排序的部分。</li>
</ol>
</li>
<li><p>注意点：适用于小数组或基本有序的大数组，效率高于选择排序和冒泡排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将arr[i]与已排序的arr[0...i-1]中的元素比较，找到插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      j = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul>
<li>思路：<ol>
<li>将数组分成若干个小数组。</li>
<li>逐个合并这些小数组，使其有序。</li>
<li>最终得到一个有序的大数组。</li>
</ol>
</li>
<li>注意点：需要额外的内存空间来存储临时数组，适用于大数据量且内存充足的情况。<br>在实现这些算法时，需要注意以下几点：</li>
<li>算法的时间复杂度和空间复杂度。</li>
<li>算法稳定性，即相同元素的相对顺序在排序后是否保持不变。</li>
<li>边界条件处理，如空数组、重复元素等。</li>
<li>优化措施，如减少不必要的交换和比较，选择合适的算法参数等。</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul>
<li><p>思路：</p>
<ol>
<li>选择一个增量序列。</li>
<li>根据增量将数组分成多个子序列。</li>
<li>对每个子序列使用插入排序。</li>
<li>缩小增量，重复上述步骤。</li>
</ol>
</li>
<li><p>注意点：增量序列的选择对性能有重要影响，适用于中等大小的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid);</span><br><span class="line">  <span class="keyword">const</span> right = arr.<span class="title function_">slice</span>(mid);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rightIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (leftIndex &lt; left.<span class="property">length</span> &amp;&amp; rightIndex &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(left[leftIndex++]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(right[rightIndex++]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">concat</span>(left.<span class="title function_">slice</span>(leftIndex)).<span class="title function_">concat</span>(right.<span class="title function_">slice</span>(rightIndex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul>
<li>思路：<ol>
<li>构建一个最大堆。</li>
<li>交换堆顶元素（最大值）与堆底元素。</li>
<li>重新调整堆，使其满足最大堆性质。</li>
<li>重复步骤2和3，直到堆中只剩下一个元素。</li>
</ol>
</li>
<li>注意点：堆的维护和调整对性能有重要影响，适用于大数据量。</li>
</ul>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul>
<li>思路：<ol>
<li>找出数组中的最大值和最小值。</li>
<li>创建一个计数数组，大小为最大值与最小值之差加1。</li>
<li>计算每个元素出现的次数。</li>
<li>根据计数数组重建原数组。</li>
</ol>
</li>
<li>注意点：适用于非负整数排序，且最大值和最小值之间的范围不大。</li>
</ul>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul>
<li>思路：<ol>
<li>将数组划分成多个桶。</li>
<li>每个桶内部进行排序（可以使用其他排序算法）。</li>
<li>合并所有桶的元素，得到排序后的数组。</li>
</ol>
</li>
<li>注意点：适用于数据分布均匀且可以划分为多个桶的情况。</li>
</ul>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul>
<li>思路：<ol>
<li>按照元素的每个位（个位、十位、百位等）进行排序。</li>
<li>从最低位开始，使用计数排序或其他稳定排序算法。</li>
<li>逐步排序到最高位，得到最终排序结果。</li>
</ol>
</li>
<li>注意点：适用于非负整数排序，且数字位数不多的情况。<br>在实现这些算法时，需要注意以下几点：</li>
<li>算法的时间复杂度和空间复杂度。</li>
<li>算法稳定性，即相同元素的相对顺序在排序后是否保持不变。</li>
<li>边界条件处理，如空数组、重复元素等。</li>
<li>优化措施，如减少不必要的交换和比较，选择合适的算法参数等。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>查找算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经-Vue(二)</title>
    <url>/2024/04/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F-Vue(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="Vuex的属性"><a href="#Vuex的属性" class="headerlink" title="Vuex的属性"></a><strong>Vuex的属性</strong></h3><p><code>state</code> &#x3D;&gt; 全局共享数据</p>
<p><code>getters</code> &#x3D;&gt; 二次计算的数据</p>
<p><code>mutations</code> &#x3D;&gt; 同步方法</p>
<p><code>actions</code> &#x3D;&gt; 异步方法 &#x2F; 提交数据</p>
<p><code>modules</code> &#x3D;&gt; 模块划分<br>对比MVC的模型来看，<code>state</code>看成一个数据库，只是它是响应式的，刷新之后页面数据就会改变；actions看成controller层，做数据的业务逻辑；mutations看成model层，做数据的增删改查操作。</p>
<h3 id="state的使用"><a href="#state的使用" class="headerlink" title="state的使用"></a><strong><code>state</code>的使用</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.state.xxx</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// mapState: 把 state 属性映射到 computed 身上</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">   <span class="title class_">Vuex</span>.<span class="title function_">mapState</span>(&#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="function"><span class="params">state</span>=&gt;</span>state.<span class="property">inputVal</span>,</span><br><span class="line">      <span class="attr">n</span>: <span class="function"><span class="params">state</span>=&gt;</span>state.<span class="property">n</span></span><br><span class="line">  &#125;)   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写形式：</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">	...<span class="title function_">mapState</span>([<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;n&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>this.$store.state.xxx</code>可以修改数据，<code>mapState</code>不能修改数据。</p>
<h3 id="修改getter的值"><a href="#修改getter的值" class="headerlink" title="修改getter的值**"></a>修改<code>getter</code>的值**</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.<span class="property">xxx</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    ...<span class="title class_">Vuex</span>.<span class="title function_">mapGetters</span>(&#123;</span><br><span class="line">        <span class="title class_">NumN</span>:<span class="string">&quot;NumN&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;  </span><br><span class="line">	...<span class="title function_">mapGetters</span>([<span class="string">&#x27;NumN&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getters</code>类似于组件里面<code>computed</code>，同时也<strong>监听属性的变化</strong>，当<code>state</code>中的属性发生改变的时候就会触发<code>getters</code>里面的方法。<code>getters</code>里面的每一个方法中都会有一个参数 <code>state</code>。</p>
<h3 id="mutation-和-action-的区别"><a href="#mutation-和-action-的区别" class="headerlink" title="mutation 和 action 的区别"></a><strong><code>mutation</code> 和 <code>action</code> 的区别</strong></h3><p><code>mutations</code>里面的函数主要用来修改<code>state</code>中的数据。<code>mutations</code>里面的所有方法都会有2个参数，一个是<code>store</code>中的<code>state</code>，另外一个是需要传递的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mapMutations 把 mutations 里面的方法映射到 methods 中</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title class_">Vuex</span>.<span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">        <span class="attr">handleAdd</span>:<span class="string">&quot;handlMutationseAdd&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;  </span><br><span class="line">	...<span class="title function_">mapMutations</span>([<span class="string">&#x27;handlMutationseAdd&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>actions</code>里面的函数主要用来处理<strong>异步操作</strong>以及一些业务逻辑,每一个函数里面都有一个形参，这个形参是一个对象，里面有一个<code>commit</code>方法，这个方法用来**触发<code>mutations</code>**里面的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mapMutations 把 actions 里面的方法映射到 methods 中</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title class_">Vuex</span>.<span class="title function_">mapActionss</span>(&#123;</span><br><span class="line">        <span class="attr">handleAdd</span>:<span class="string">&quot;handlMutationseAdd&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActionss&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;  </span><br><span class="line">	...<span class="title function_">mapActionss</span>([<span class="string">&#x27;handlMutationseAdd&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="modules的使用"><a href="#modules的使用" class="headerlink" title="modules的使用"></a><strong>modules的使用</strong></h3><p>modules是把公共的状态按照模块进行划分。每个模块都相当于一个小型的<code>Vuex</code>，即每个模块里面都会有<code>state</code> <code>getters</code> <code>actions</code> <code>mutations</code>。</p>
<p>多人协作开发的时候，可能子模块和主模块中的函数名字会相同，这样在调用函数的时候，相同名字的函数都会被调用，就会发生问题。为了解决这个问题，导出模块的时候要加 <code>namespace:true</code> ，主要的作用是将每个模块都有独立命名空间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块化后，<code>store</code>实例的<code>state</code>属性访问方式为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">todo</span>.<span class="property">inputVal</span></span><br></pre></td></tr></table></figure>

<h3 id="Vuex持久化储存"><a href="#Vuex持久化储存" class="headerlink" title="Vuex持久化储存"></a><strong>Vuex持久化储存</strong></h3><p><code>Vuex</code>本身不具有持久化存储的能力，vuex是单向数据流，存在vuex中的变量都是响应式数据。组件中一般会通过computed来使用store中的状态、且有缓存，但是当我们去刷新浏览器的时候，store中的状态都会被清空、重新初始化为最初的状态。要实现持久化存储，就是将其状态保存到<code>localStorage</code>或者<code>sessionStorage</code>中，实现方法有两种：</p>
<ol>
<li><p>使用插件：<code>vuex-persistedstate</code></p>
<p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vuex-persistedstate</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;./modules/test&#x27;</span></span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&#x27;./modules/user&#x27;</span></span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">&quot;vuex-persistedstate&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    test,</span><br><span class="line">    user</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* vuex数据持久化配置 */</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">createPersistedState</span>(&#123;</span><br><span class="line">      <span class="comment">// 存储方式：localStorage、sessionStorage、cookies</span></span><br><span class="line">      <span class="attr">storage</span>: <span class="variable language_">window</span>.<span class="property">sessionStorage</span>,</span><br><span class="line">      <span class="comment">// 存储的 key 的key值</span></span><br><span class="line">      <span class="attr">key</span>: <span class="string">&quot;store&quot;</span>,</span><br><span class="line">      <span class="title function_">reducer</span>(<span class="params">state</span>) &#123; <span class="comment">//render错误修改</span></span><br><span class="line">      <span class="comment">// 要存储的数据：本项目采用es6扩展运算符的方式存储了state中所有的数据</span></span><br><span class="line">        <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>如果只需要存储 <code>state</code> 中一部分数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="title function_">createPersistedState</span>(&#123;</span><br><span class="line">    <span class="attr">storage</span>: <span class="variable language_">window</span>.<span class="property">sessionStorage</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;store&quot;</span>,</span><br><span class="line">    <span class="comment">// 只持久化存储user模块的状态</span></span><br><span class="line">    <span class="attr">paths</span>: [<span class="string">&#x27;user&#x27;</span>]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>自己实现：</p>
<p><code>utils/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储方式：localStorage、sessionStorage、cookies</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SessionUtils</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">getItem</span>(key))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">removeItem</span>(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在vuex中的使用：<code>store/index.js</code> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">SessionUtils</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/index.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="title class_">SessionUtils</span>.<span class="title function_">get</span>(<span class="string">&#x27;count&#x27;</span>) || <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">UPDATE_COUNT</span>(<span class="params">state, count</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">      <span class="title class_">SessionUtils</span>.<span class="title function_">set</span>(<span class="string">&#x27;count&#x27;</span>, state.<span class="property">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="路由的模式和区别"><a href="#路由的模式和区别" class="headerlink" title="路由的模式和区别"></a>路由的模式和区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">history</th>
<th align="center">hash</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表象</td>
<td align="center"><a href="https://zhuanlan.zhihu.com/p/24814675">https://zhuanlan.zhihu.com/p/24814675</a></td>
<td align="center"><a href="http://example.com/#/foo/bar">http://example.com/#/foo/bar</a></td>
</tr>
<tr>
<td align="center">发送请求</td>
<td align="center">通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。会发一次请求</td>
<td align="center">hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。不会发请求</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">更加直观和正式</td>
<td align="center">兼容性更好</td>
</tr>
<tr>
<td align="center">项目打包前自测</td>
<td align="center">默认看不到内容</td>
<td align="center">默认可以看到内容</td>
</tr>
</tbody></table>
<h3 id="子路由和动态路由"><a href="#子路由和动态路由" class="headerlink" title="子路由和动态路由"></a>子路由和动态路由</h3><p><em>动态路由</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 动态字段以冒号开始</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><em>子路由</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/profile 匹配成功</span></span><br><span class="line">        <span class="comment">// UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;profile&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">UserProfile</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">        <span class="comment">// UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">UserPosts</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="路由传值"><a href="#路由传值" class="headerlink" title="路由传值"></a>路由传值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">uname</span>: <span class="variable language_">this</span>.<span class="property">userName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">uname</span>: <span class="variable language_">this</span>.<span class="property">userName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="导航故障"><a href="#导航故障" class="headerlink" title="导航故障"></a>导航故障</h3><p>当使用 <code>router-link</code> 组件时，Vue Router 会自动调用 <code>router.push</code> 来触发一次导航。 有些情况会留在同一页面上：</p>
<ul>
<li>用户已经位于他们正在尝试导航到的页面</li>
<li>一个<a href="https://v3.router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>通过调用 <code>next(false)</code> 中断了这次导航</li>
<li>一个<a href="https://v3.router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>抛出了一个错误，或者调用了 <code>next(new Error())</code></li>
</ul>
<p>当使用 <code>router-link</code> 组件时，这些失败都不会打印出错误。如果你使用 <code>router.push</code> 或者 <code>router.replace</code> 的话，可能会在控制台看到一条 <em>“Uncaught (in promise) Error”</em> 这样的错误，后面跟着一条更具体的消息。</p>
<p>解决方法是在请求的后面打印抛出的错误。</p>
<h3 id="route-和-router"><a href="#route-和-router" class="headerlink" title="$route 和 $router"></a><code>$route</code> 和 <code>$router</code></h3><p><code>$route</code>是路由信息对象，里面主要包含路由的一些基本信息，包含当前的路径，参数，query对象等。(包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom)</p>
<p><em>route object 出现在多个地方:</em></p>
<ol>
<li>组件内的 this.route和route watcher 回调（监测变化处理）;</li>
<li>router.match(location) 的返回值</li>
<li>scrollBehavior 方法的参数</li>
</ol>
<p>方法：</p>
<ol>
<li><code>$route.path</code> 字符串，对应当前路由的路径，总是解析为绝对路径，如 “&#x2F;foo&#x2F;bar”</li>
<li><code>$route.params</code> 一个 key&#x2F;value 对象，包含了 动态片段 和 全匹配片段，<br>   如果没有路由参数，就是一个空对象。</li>
<li><code>$route.query</code>  一个 key&#x2F;value 对象，表示 URL 查询参数。<br>   例如，对于路径 &#x2F;foo?user&#x3D;1，则有 $route.query.user &#x3D;&#x3D; 1, 如果没有查询参数，则是个空对象。</li>
<li><code>$route.hash</code> 当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点</li>
<li><code>$route.fullPath</code> 完成解析后的 URL，包含查询参数和 hash 的完整路径。</li>
<li><code>$route.matched</code> 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</li>
<li><code>$route.name</code>  当前路径名字</li>
<li><code>$route.meta</code>  路由元信息</li>
</ol>
<p><code>$router</code>对象是全局路由的实例，是router构造方法的实例,包含了一些路由的跳转方法，钩子函数等</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=123</span></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;123&#x27;</span> &#125;&#125;)</span><br><span class="line"><span class="comment">// 页面路由跳转 前进或者后退</span></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">go</span>(-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 一般使用replace来做404页面</span></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">replace</span>(<span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p><em>全局守卫</em>  <strong>(使用不多)</strong></p>
<p><code>router.beforeEach(fn)</code>: 全局前置路由守卫</p>
<p><code>afterEach(fn)</code>: 全局后置路由守卫, 表示离开当前路由时执行</p>
<p>fn中有三个参数</p>
<ul>
<li>to:表示要去哪里</li>
<li>from：表示从哪里来</li>
<li>next：表示通不通过</li>
</ul>
<p>关于<code>next()</code>的使用</p>
<ul>
<li><code>next()</code> 等价于 next( true ) 表示可以从当前路由跳转到目标路由</li>
<li><code>next( false )</code> 表示不通过， 表示从当前路由跳转不到目标路由</li>
<li><code>next(’/login’)</code> 等价于 next({path:’&#x2F;login’,params,query}), 跳转指定的路由</li>
<li>next( fn ) 数据预加载</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>( <span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;name&#x27;</span>);<span class="comment">//查看本地存储上是否有name对象</span></span><br><span class="line">    <span class="keyword">if</span>( name || to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>)&#123;<span class="comment">//短路逻辑，有就可以继续执行，没有就跳转到登录页面</span></span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="title function_">next</span>( <span class="string">&#x27;/login&#x27;</span> )<span class="comment">//跳转登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">afterEach</span>( <span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(to.<span class="property">path</span> === <span class="string">&#x27;/user&#x27;</span>)&#123;<span class="comment">//当to的path值等于这个时</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;确定进入user吗&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><em>全局的解析守卫</em></p>
<p>  在 <code>2.5.0+</code>你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。必须保证整个项目的守卫和异步路由组件解析完成</p>
<p><em>路由独享守卫</em>——<strong>写在路由表里</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line"><span class="attr">beforeEnter</span>: <span class="function">(<span class="params"> to,<span class="keyword">from</span>,next </span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(to)</span></span><br><span class="line">    <span class="keyword">const</span> name = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;name&#x27;</span>);<span class="comment">//判断本地存储有没有name对象</span></span><br><span class="line">    <span class="keyword">if</span>( name)&#123;<span class="comment">//存在就可以继续执行</span></span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;你还没有登录，点击跳转登录&#x27;</span>)<span class="comment">//不存在就弹窗告诉没有登录，点击登录</span></span><br><span class="line">                <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><em>组件内守卫</em> <strong>(不推荐用)</strong></p>
<ul>
<li>beforeRouteEnther( (to,from,next) &#x3D;&gt;{} ) 进入组件时触发</li>
<li>beforeRouteUpdate( (to,from,next) &#x3D;&gt;{} ) 数据改变时触发</li>
<li>beforeRouteLeave( (to,from,next) &#x3D;&gt;{} ) 离开组件时触发</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断两个输入框是否有值输入，有就可以直接离开，没有弹窗告诉确定是否离开，防止误触</span></span><br><span class="line"><span class="title function_">beforeRouteLeave</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">username</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">pwd</span>)&#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">confirm</span>(<span class="string">&#x27;你确定要离开吗&#x27;</span>))&#123;<span class="comment">//返回一个布尔值</span></span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听路由"><a href="#监听路由" class="headerlink" title="监听路由"></a>监听路由</h3><ol>
<li><p>使用 <code>watch</code> 监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">  $router(to,<span class="keyword">from</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(to.<span class="property">path</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用 <code>beforeRouteUpdate</code> 监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">	<span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>面试</tag>
        <tag>web前端</tag>
        <tag>vuex</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
</search>
