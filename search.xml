<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS基础补充</title>
      <link href="/2024/05/08/3Y38JTY/"/>
      <url>/2024/05/08/3Y38JTY/</url>
      
        <content type="html"><![CDATA[<h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="JS-操作事件流"><a href="#JS-操作事件流" class="headerlink" title="JS 操作事件流"></a>JS 操作事件流</h4><ol><li><p><strong>改变 HTML 图像</strong></p><p> 本例会动态地改变 HTML <image> 的来源（src）：</image></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 使用 三目运算符</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">changeImage</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myimage&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    s.<span class="property">src</span> = s.<span class="property">src</span>.<span class="title function_">match</span>(<span class="string">&#x27;bulboff&#x27;</span>) ? <span class="string">&quot;/images/pic_bulbon.gif&quot;</span> : <span class="string">&quot;/images/pic_bulboff.gif&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 使用事件流获取标签</span></span></span><br><span class="line"><span class="language-javascript">&lt;img id=<span class="string">&quot;myimage&quot;</span> onclick=<span class="string">&quot;~function(e)&#123;e.src=e.src.match(&#x27;bulboff&#x27;)?&#x27;/images/pic_bulbon.gif&#x27;:&#x27;/images/pic_bulboff.gif&#x27;&#125;(this)&quot;</span> src=<span class="string">&quot;/images/pic_bulboff.gif&quot;</span> width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;myimage&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changeImage()&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/pic_bulboff.gif&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>点击灯泡就可以打开或关闭这盏灯<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 在这段代码中，<code>~function(e)&#123;...&#125;(this)</code> 表示使用了一个<strong>自执行的匿名函数</strong>。这个匿名函数接收一个参数<code> e</code>，表示当前被点击的图片元素，然后对这个元素的 <code>src</code> 属性进行修改，实现灯泡的打开和关闭。</p><p>   需要注意的是，<code>~function(e)&#123;...&#125;(this)</code> 中的波浪线 <code>~</code> 并不是必须的，它的作用是将匿名函数转换为一个表达式，从而避免将 <strong>function</strong> 关键字视为一个语句而出现语法错误。因此，这个波浪线可以省略，代码也可以写成 <code>(function(e)&#123;...&#125;)(this)</code> 的形式，效果是一样的。</p></li></ol><hr><h4 id="JS输入输出"><a href="#JS输入输出" class="headerlink" title="JS输入输出"></a>JS输入输出</h4><ol><li><p>DOM 文件流</p><p><strong>DOM (Document Object Model)（文档对象模型）</strong>是用于访问 HTML 元素的正式 W3C 标准。</p><p>格式 <code>&lt;script&gt;</code></p><p>那些老旧的实例可能会在 <code>&lt;script&gt;</code> 标签中使用 <code>type=&quot;text/javascript</code>。</p><p>现在已经不必这样做了。</p><p><strong>脚本位置</strong></p><p>在 <code>&lt;head&gt;</code> 或者 <code>&lt;body&gt;</code> 的JavaScript</p><p>外部脚本不能包含 <code>&lt;script&gt;</code> 标签。</p><p><strong>输出数据</strong></p><p>window.alert() 弹出警告框。</p><p>document.write() 方法将内容写到 HTML 文档中。</p><p>innerHTML 写入到 HTML 元素。</p><p>console.log() 写入到浏览器的控制台。</p><p><strong>输出内容</strong></p><p>使用 document.write() 向文档输出写内容。</p><p>&#x3D;&#x3D;如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖&#x3D;&#x3D;</p><p><strong>写到控制台(调试模式)</strong></p><p>使用 <code>console.log()</code> 方法在浏览器中显示 JavaScript 值。</p><p>F12 启用调试模式， 在调试窗口中点击 <code>&quot;Console&quot;</code> 菜单</p></li><li><p><code>console.log()</code> 用法也可以像 C 语言用 <strong>%s</strong> 来使用变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%s world&#x27;</span>, hello)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%d + 1 = 3&#x27;</span>, one)</span><br></pre></td></tr></table></figure><hr><h4 id="JS-语法"><a href="#JS-语法" class="headerlink" title="JS 语法"></a>JS 语法</h4></li><li><p>javascript字面量：在编程语言中，一般固定值称为字面量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number 通过数字字面量赋值 </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Number 通过表达式字面量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String 通过字符串字面量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array  通过数组字面量赋值 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object 通过对象字面量赋值</span></span><br></pre></td></tr></table></figure><hr><h4 id="JS变量"><a href="#JS变量" class="headerlink" title="JS变量"></a>JS变量</h4></li><li><p><strong>JavaScript 允许重复声明变量，后声明的覆盖之前的</strong></p><p>JavaScript 允许变量被重复声明，在声明变量时 JavaScript 会自行判断这个变量是否已经被声明了，如果已经被声明（即已经存在），那么重复声明（即除了变量的非首次声明）会被跳过，不再执行声明的操作。</p><p>JavaScript 变量的值是可以被重复赋值的，最后的赋值是这个变量最后的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test1</span>();     <span class="comment">//输出test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();     <span class="comment">//输出 &quot;test arg 0 + undefined&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">arg1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test arg &quot;</span> + <span class="variable language_">arguments</span>.<span class="property">length</span> + <span class="string">&quot; + &quot;</span> + arg1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//输出 &quot;test arg 2 + 1&quot;</span></span><br></pre></td></tr></table></figure><p>实参个数如果比形参少，那么剩下的默认赋值为 <strong>undefined</strong>，如果实参传的比形参数量多，那么是全部都会被传进去的，只不过没有对应的形参可以引用（但可以用 arguments 来获取剩下的参数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">arg1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//输出 1 2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>变量与函数重名的时候，变量生效</strong></p><p>这涉及到了变量和函数的预解析：</p><ul><li>变量声明会被顶置，函数声明也会被顶置且比变量更先声明。</li><li>变量的声明和赋值语句一起写时，JS引擎在解析时，会将其拆成声明和赋值2部分，声明置顶，赋值保留在原来位置。</li><li>声明过的变量不会再重复声明。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;function&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);     <span class="comment">//输出 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>());   <span class="comment">//报错Uncaught TypeError: a is not a function</span></span><br></pre></td></tr></table></figure><p>JS 中有两种函数，一种是普通函数，一种是函数对象。下面的这种就是“函数对象”，它实际上是声明一个匿名函数，然后将该函数的<strong>init</strong>方法赋值给该变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;function&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//输出[Function: a]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>());   <span class="comment">//输出 &quot;function&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>函数与内部变量重名</strong></p><p>定义普通函数，即在 window 变量下，定义一个 key，它的名字为该函数名，值为该函数的地址。函数内部的 this 指向 window 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//输出 window&#123;...&#125;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;         <span class="comment">//即 window.a = 1，此时window下的function a已经被该变量覆盖了。</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">5</span>;          <span class="comment">//下面的这几个变量都是局部变量，仅在花括号范围内有效。  </span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">&quot;value&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;function&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);         <span class="comment">//输出 function a &#123;...&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>());       <span class="comment">//输出 &quot;function&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);         <span class="comment">//输出 1, 此时window下的function a已经被改变了。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">Uncaught ReferenceError: v is not defined</span></span><br><span class="line"><span class="comment">    (anonymous function) @ mycolor.html:15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型"></a>JS 数据类型</h4><table><thead><tr><th></th><th align="center">JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。</th></tr></thead></table><ol><li><p>undefined 和 Null</p><p>在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法。</p><p>对象只有被定义才有可能为 null，否则为 undefined。</p><p>如果我们想测试对象是否存在，在对象还没定义时将会抛出一个错误。</p><p>错误的使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myObj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> myObj !== <span class="string">&quot;undefined&quot;</span>) </span><br></pre></td></tr></table></figure><p>正确的方式是我们需要先使用 typeof 来检测对象是否已定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> myObj !== <span class="string">&quot;undefined&quot;</span> &amp;&amp; myObj !== <span class="literal">null</span>) </span><br></pre></td></tr></table></figure></li><li><p>声明变量类型</p><p>当您声明新变量时，可以使用关键词 “new” 来声明其类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carname=<span class="keyword">new</span> <span class="title class_">String</span>;</span><br><span class="line"><span class="keyword">var</span> x=   <span class="keyword">new</span> <span class="title class_">Number</span>;</span><br><span class="line"><span class="keyword">var</span> y=   <span class="keyword">new</span> <span class="title class_">Boolean</span>;</span><br><span class="line"><span class="keyword">var</span> cars=  <span class="keyword">new</span> <span class="title class_">Array</span>;</span><br><span class="line"><span class="keyword">var</span> person= <span class="keyword">new</span> <span class="title class_">Object</span>;</span><br></pre></td></tr></table></figure></li><li><p>对象属性有两种寻址方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> name=person.<span class="property">lastname</span>;</span><br><span class="line">   name=person[<span class="string">&quot;lastname&quot;</span>];</span><br></pre></td></tr></table></figure></li></ol><p>javaScript对象中属性具有唯一性（这里的属性包括方法），如果有两个重复的属性，则以最后赋值为准。比如同时存在两个play:</p><ol start="4"><li><p>在定义后可以通过 <strong>typeof()</strong> 来获取JavaScript中变量的数据类型.</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">typeof</span>(<span class="string">&#x27;hello&#x27;</span>)  <span class="comment">// string</span></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// object</span></span><br><span class="line">a = <span class="number">666</span>;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// number </span></span><br><span class="line">a = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// symbol</span></span><br><span class="line">     </span><br><span class="line">a = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// function</span></span><br><span class="line">     </span><br><span class="line">a = [];</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// object</span></span><br><span class="line">a = &#123;&#125;;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// object</span></span><br><span class="line">a = <span class="regexp">/aaa/g</span>;</span><br><span class="line"><span class="keyword">typeof</span> a;    <span class="comment">// object   </span></span><br></pre></td></tr></table></figure><p>   &#x3D;&#x3D;<strong>注：</strong>typeof 不能用来判断是 <strong>Array</strong> 还是 <strong>Object</strong>&#x3D;&#x3D;</p><p>   使用以下方法判断：</p><ol><li>使用 isArray 方法</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">cars[<span class="number">0</span>]=<span class="string">&quot;Saab&quot;</span>;</span><br><span class="line">cars[<span class="number">1</span>]=<span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">cars[<span class="number">2</span>]=<span class="string">&quot;BMW&quot;</span>;</span><br><span class="line"><span class="comment">// 判断是否支持该方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="property">isArray</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cars)) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;该对象是一个数组。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 instanceof 操作符</li></ol><p>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof</a>：&#x3D;&#x3D;用来判断某个构造函数的 prototype 属性所指向的对象是否存在于另外一个要检测对象的原型链上&#x3D;&#x3D;,简单说就是判断一个引用类型的变量具体是不是某种类型的对象</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">cars[<span class="number">0</span>]=<span class="string">&quot;Saab&quot;</span>;</span><br><span class="line">cars[<span class="number">1</span>]=<span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">cars[<span class="number">2</span>]=<span class="string">&quot;BMW&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cars <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;该对象是一个数组。&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>数据类型转换</p><ol><li>利用 toString() 方法可以把数值转换为字符串。</li><li>使用 parseInt() 和 parseFloat() 方法可以把字符串转换为数值。</li><li>要把任何值转换为布尔型数据，在值的前面增加两个 <strong>!!</strong> 感叹号即可，**!!0** 为 <strong>False</strong>，其余的均为 <strong>True</strong>。</li></ol></li><li><p><strong>基本类型</strong></p><p>JavaScript 中共有 6 种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol (new in ES 6) ！</p><p><strong>约定：</strong>基本数据类型与原始数据类型等意。</p><p>&#x3D;&#x3D;基本数据类型的值是按值访问的。&#x3D;&#x3D;</p><ul><li><p>基本类型的值是不可变的</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123hello321&quot;</span>;</span><br><span class="line">str.<span class="title function_">toUpperCase</span>();     <span class="comment">// 123HELLO321</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);      <span class="comment">// 123hello321</span></span><br></pre></td></tr></table></figure></li><li><p>基本类型的比较是它们的值的比较</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b);    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p> 上面 a 和 b 的数据类型不同，但是也可以进行值的比较，这是因为在比较之前，自动进行了数据类型的 隐式转换。</p><ul><li>&#x3D;&#x3D; : 只进行值的比较</li><li>&#x3D;&#x3D;&#x3D; : 不仅进行值得比较，还要进行数据类型的比较</li></ul></li></ul></li><li><p><strong>引用类型</strong></p><p>  除过上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型 等。</p><p>  <strong>引用类型的值是按引用访问的。</strong></p><ul><li><p>引用类型的值是可变的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;zyj&quot;</span>&#125;;   <span class="comment">// 创建一个对象</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;percy&quot;</span>;       <span class="comment">// 改变 name 属性的值</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">21</span>;             <span class="comment">// 添加 age 属性</span></span><br><span class="line">obj.<span class="property">giveMeAll</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; : &quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;;                        <span class="comment">// 添加 giveMeAll 方法</span></span><br><span class="line">obj.<span class="title function_">giveMeAll</span>();</span><br></pre></td></tr></table></figure></li><li><p>引用类型的比较是引用的比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;    <span class="comment">// 新建一个空对象 obj1</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;    <span class="comment">// 新建一个空对象 obj2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 == obj2);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因为 obj1 和 obj2 分别引用的是存放在<strong>堆内存</strong>中的2个不同的对象，故变量 obj1 和 obj2 的值（引用地址）也是不一样的！</p></li></ul><hr></li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><strong>变量作用域</strong></p><p>变量在函数内声明，变量为局部变量，具有&#x3D;&#x3D;局部作用域&#x3D;&#x3D;。因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。</p><p>变量在函数外定义，即为全局变量。全局变量有&#x3D;&#x3D;全局作用域&#x3D;&#x3D;: 网页中所有脚本和函数均可使用。<strong>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</strong>全局变量在页面关闭后销毁。</p><hr><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ol><li><p><strong>字符串可以是对象</strong></p><p>通常， JavaScript 字符串是原始值，可以使用字符创建： **var firstName &#x3D; “John”**但我们也可以使用 new 关键字将字符串定义为一个对象： <strong>var firstName &#x3D; new String(“John”)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="keyword">typeof</span> x <span class="comment">// 返回 String</span></span><br><span class="line"><span class="keyword">typeof</span> y <span class="comment">// 返回 Object</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;John&quot;</span>;              </span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">(x === y) <span class="comment">// 结果为 false，因为 x 是字符串，y 是对象</span></span><br></pre></td></tr></table></figure><p> |  | 不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用： |</p></li></ol><p>| ————————– | ———————————————————— |</p><ol start="2"><li><p><strong>字符串属性</strong></p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;constructor&#x3D;&#x3D;</td><td align="left">返回创建字符串属性的函数</td></tr><tr><td align="left">length</td><td align="left">返回字符串的长度</td></tr><tr><td align="left">&#x3D;&#x3D;prototype&#x3D;&#x3D;</td><td align="left">允许您向对象添加属性和方法</td></tr></tbody></table><hr></li><li><p><strong>字符串方法</strong></p><p> 更多方法实例可以参见：<a href="https://www.runoob.com/jsref/jsref-obj-string.html">JavaScript String 对象</a>。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">charAt()</td><td align="left">返回指定索引位置的字符</td></tr><tr><td align="left">charCodeAt()</td><td align="left">返回指定索引位置字符的 Unicode 值</td></tr><tr><td align="left">concat()</td><td align="left">连接两个或多个字符串，返回连接后的字符串</td></tr><tr><td align="left">fromCharCode()</td><td align="left">将 Unicode 转换为字符串</td></tr><tr><td align="left">indexOf()</td><td align="left">返回字符串中检索指定字符第一次出现的位置</td></tr><tr><td align="left">lastIndexOf()</td><td align="left">返回字符串中检索指定字符最后一次出现的位置</td></tr><tr><td align="left">&#x3D;&#x3D;localeCompare()&#x3D;&#x3D;</td><td align="left">用本地特定的顺序来比较两个字符串</td></tr><tr><td align="left">&#x3D;&#x3D;match()&#x3D;&#x3D;</td><td align="left">找到一个或多个正则表达式的匹配</td></tr><tr><td align="left">&#x3D;&#x3D;replace()&#x3D;&#x3D;</td><td align="left">替换与正则表达式匹配的子串</td></tr><tr><td align="left">&#x3D;&#x3D;search()&#x3D;&#x3D;</td><td align="left">检索与正则表达式相匹配的值</td></tr><tr><td align="left">slice()</td><td align="left">提取字符串的片断，并在新的字符串中返回被提取的部分</td></tr><tr><td align="left">split()</td><td align="left">把字符串分割为子字符串数组</td></tr><tr><td align="left">&#x3D;&#x3D;substr()&#x3D;&#x3D;</td><td align="left">从起始索引号提取字符串中指定数目的字符</td></tr><tr><td align="left">substring()</td><td align="left">提取字符串中两个指定的索引号之间的字符</td></tr><tr><td align="left">toLocaleLowerCase()</td><td align="left">根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射</td></tr><tr><td align="left">toLocaleUpperCase()</td><td align="left">根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射</td></tr><tr><td align="left">toLowerCase()</td><td align="left">把字符串转换为小写</td></tr><tr><td align="left">toString()</td><td align="left">返回字符串对象值</td></tr><tr><td align="left">toUpperCase()</td><td align="left">把字符串转换为大写</td></tr><tr><td align="left">trim()</td><td align="left">移除字符串首尾空白</td></tr><tr><td align="left">valueOf()</td><td align="left">返回某个字符串对象的原始值</td></tr></tbody></table></li><li><p>JavaScript &#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D; 区别</p><ol><li>对于 string、number 等基础类型，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 是有区别</li></ol><ul><li><p>a) 不同类型间比较，&#x3D;&#x3D; 之比较 “转化成同一类型后的值” 看 “值” 是否相等，&#x3D;&#x3D;&#x3D; 如果类型不同，其结果就是不等。</p></li><li><p>b）同类型比较，直接进行 “值” 比较，两者结果一样。</p></li></ul><ol start="2"><li><p>对于 Array,Object 等高级类型，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 是没有区别的————进行 “指针地址” 比较</p></li><li><p>基础类型与高级类型，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 是有区别的</p><ol><li>a）对于 &#x3D;&#x3D;，将高级转化为基础类型，进行 “值” 比较</li><li>b）因为类型不同，&#x3D;&#x3D;&#x3D; 结果为 false</li></ol></li><li><p>!&#x3D; 为 &#x3D;&#x3D; 的非运算，!&#x3D;&#x3D; 为 &#x3D;&#x3D;&#x3D; 的非运算</p></li></ol></li><li><p>模版字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`string text`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text line 1</span></span><br><span class="line"><span class="string"> string text line 2`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br><span class="line"></span><br><span class="line">tagFunction<span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong>string text</strong>：将成为模板字面量的一部分的字符串文本。几乎允许所有字符，包括换行符和其他空白字符。但是，除非使用了标签函数，否则无效的转义序列将导致语法错误。</li><li><strong>expression</strong>：要插入当前位置的表达式，其值被转换为字符串或传递给 tagFunction。</li><li><strong>tagFunction</strong>：如果指定，将使用模板字符串数组和替换表达式调用它，返回值将成为模板字面量的值。</li></ul><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Runoob&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span> and I&#x27;m <span class="subst">$&#123;age&#125;</span> years old.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> price = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">VAT</span> = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> total = <span class="string">`Total: <span class="subst">$&#123;(price * (<span class="number">1</span> + VAT)).toFixed(<span class="number">2</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str =<span class="string">`</span></span><br><span class="line"><span class="string">Name:<span class="subst">$&#123;name&#125;</span></span></span><br><span class="line"><span class="string">age:<span class="subst">$&#123;age&#125;</span></span></span><br><span class="line"><span class="string">function:<span class="subst">$&#123;hello()&#125;</span></span></span><br><span class="line"><span class="string">sanmu: <span class="subst">$&#123;age &gt;</span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="number">30</span> ? <span class="string">&#x27;over 30&#x27;</span>: <span class="string">&#x27;under 30&#x27;</span> &#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure></li></ol><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>对字符串和数字进行加法运算</strong></p><ol><li><p>两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串，如下实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span>+<span class="number">5</span>; <span class="comment">// 10</span></span><br><span class="line">y=<span class="string">&quot;5&quot;</span>+<span class="number">5</span>; <span class="comment">//55</span></span><br><span class="line">z=<span class="string">&quot;Hello&quot;</span>+<span class="number">5</span>; <span class="comment">// Hello5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1=<span class="number">5</span>+<span class="number">5</span>+<span class="string">&quot;abc&quot;</span>; <span class="comment">//结果将是&quot;10abc&quot;</span></span><br><span class="line"><span class="keyword">var</span> result2= <span class="string">&quot;&quot;</span>+<span class="number">5</span>+<span class="number">5</span>+<span class="string">&quot;abc&quot;</span>; <span class="comment">//结果将是&quot;55abc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>空文本 <strong>+</strong> 数字得到的运算结果都是把数字转成字符串，无论文本有多少个空格。但是空格会计入长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1=<span class="string">&quot;&quot;</span>+<span class="number">5</span>;         <span class="comment">// 得到的结果是&quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2=<span class="string">&quot; &quot;</span>+<span class="number">5</span>;        <span class="comment">// 得到的结果是&quot; 5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3=<span class="string">&quot;       &quot;</span>+<span class="number">5</span>;  <span class="comment">// 得到的结果是&quot;       5&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>常见的不同类型运算的转换方式：</p><ul><li>字符串和数字相加，数字转成字符串.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one=<span class="string">&quot;This is a test&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> two=<span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> three=one+two;</span><br><span class="line"><span class="comment">// 结果：three:This is a test123</span></span><br></pre></td></tr></table></figure><ul><li>数字和布尔值相加，布尔值 false 转成 0，true 转成 1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one=<span class="number">13</span>;</span><br><span class="line"><span class="keyword">var</span> two=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> three=one+two;</span><br><span class="line"><span class="comment">// 结果 three:14</span></span><br></pre></td></tr></table></figure><ul><li>字符串与布尔值相加，布尔值转化成字符串。</li></ul></li><li><p>取模运算的结果符号只与左边值的符号有关：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">7</span> % <span class="number">3</span>; <span class="comment">// 结果为 1</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span> % (-<span class="number">3</span>); <span class="comment">// 结果为 1</span></span><br><span class="line"><span class="keyword">var</span> z = (-<span class="number">7</span>) % <span class="number">3</span>; <span class="comment">// 结果为 -1</span></span><br></pre></td></tr></table></figure><ul><li>如果 % 左边的操作数是正数，则模除的结果为正数或零；</li><li>如果 % 左边的操作数是负数，则模除的结果为负数或零。</li></ul></li><li><p>数字与 null(空值) 相加，null 转化为数字 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var car=null+3+4;    // 结果为7</span><br></pre></td></tr></table></figure><p>字符串与 null(空值) 相加，null 转化为字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var car=null+&quot;a&quot;;    // 结果为 nulla</span><br></pre></td></tr></table></figure></li><li><p>字符串一个很能强大的数据类型；在执行加 <strong>+</strong> 时,将被加的对象统一处理为字符串。</p><ol><li>bool 类型在与数字类型进行相加时，视为 0 或者 1 处理。</li><li>null 类型与数字类型进行累加时，视为 0 处理。</li><li>bool 类型与 null 类型进行累加时，视为其与整数类型累加处理。</li><li>undefined 除了与字符串进行累加时有效（undefined 视为字符串”undefined”处理），其他情况皆返回 NaN。</li></ol></li><li><p>如果要把字符串转换为数字，可以通过减 <strong>-</strong> 运算来进行，当然这里有一种情况，就是参与运算的 <strong>string</strong> 不能被转换成合法的 <strong>number</strong> 类型，那么最后结果就会返回 <strong>NaN</strong>。</p></li></ol><h4 id="JavaScript-typeof-null-和-undefined"><a href="#JavaScript-typeof-null-和-undefined" class="headerlink" title="JavaScript typeof, null, 和 undefined"></a>JavaScript typeof, null, 和 undefined</h4><ol><li><p><strong>typeof 操作符</strong></p><p>你可以使用 typeof 操作符来检测变量的数据类型。在JavaScript中，数组是一种特殊的对象类型。 因此 typeof [1,2,3,4] 返回 object。</p></li><li><p><strong>null</strong></p><p>在 JavaScript 中 null 表示 “什么都没有”。null是一个只有一个值的特殊类型。表示一个空对象引用。 用 typeof 检测 null 返回是object。</p><p>你可以设置为 null 来清空对象，你也可以设置为 undefined 来清空对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="literal">null</span>;           <span class="comment">// 值为 null(空), 但类型为对象</span></span><br><span class="line">varperson = <span class="literal">undefined</span>;     <span class="comment">// 值为 undefined, 类型undefined</span></span><br></pre></td></tr></table></figure></li><li><p><strong>undefined</strong></p><p>在 JavaScript 中, <strong>undefined</strong> 是一个没有设置值的变量。<strong>typeof</strong> 一个没有值的变量会返回 <strong>undefined</strong>。</p><p>&#x3D;&#x3D;**任何变量都可以通过设置值为 **undefined 来清空。 类型为 <strong>undefined</strong>&#x3D;&#x3D;</p></li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li><p><strong>typeof 操作符</strong></p><p>你可以使用 <strong>typeof</strong> 操作符来查看 JavaScript 变量的数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;John&quot;</span>         <span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span>          <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span>           <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>         <span class="comment">// 返回 boolean</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]       <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;   <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Date</span>()       <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;     <span class="comment">// 返回 function</span></span><br><span class="line"><span class="keyword">typeof</span> myCar         <span class="comment">// 返回 undefined (如果 myCar 没有声明)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>          <span class="comment">// 返回 object</span></span><br></pre></td></tr></table></figure></li><li><p><strong>constructor 属性</strong></p><p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;John&quot;</span>.<span class="property">constructor</span>         <span class="comment">// 返回函数 String() &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).<span class="property">constructor</span>         <span class="comment">// 返回函数 Number() &#123; [native code] &#125;</span></span><br><span class="line"><span class="literal">false</span>.<span class="property">constructor</span>         <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="property">constructor</span>       <span class="comment">// 返回函数 Array()  &#123; [native code] &#125;</span></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;.<span class="property">constructor</span> <span class="comment">// 返回函数 Object() &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="property">constructor</span>       <span class="comment">// 返回函数 Date()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;.<span class="property">constructor</span>     <span class="comment">// 返回函数 Function()&#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;你可以使用 constructor 属性来查看对象是否为数组 (包含字符串 “Array”),你可以使用 constructor 属性来查看对象是否为日期 (包含字符串 “Date”):&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isArray</span>(<span class="params">myArray</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> myArray.<span class="property">constructor</span>.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;Array&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isDate</span>(<span class="params">myDate</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> myDate.<span class="property">constructor</span>.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;Date&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型转换</p><ol><li><p><strong>将数字转换为字符串</strong></p><p>全局方法 <strong>String()</strong> 可以将数字转换为字符串。Number 方法 <strong>toString()</strong> 也是有同样的效果。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">toExponential()</td><td align="left">把对象的值转换为指数计数法。</td></tr><tr><td align="left">toFixed()</td><td align="left">把数字转换为字符串，结果的小数点后有指定位数的数字。</td></tr><tr><td align="left">toPrecision()</td><td align="left">把数字格式化为指定的长度。</td></tr></tbody></table></li><li><p><strong>将日期转换为字符串</strong></p><p>Date() 返回字符串。全局方法 String() 可以将日期对象转换为字符串。Date 方法 <strong>toString()</strong> 也有相同的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Date</span>()   <span class="comment">// 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())   <span class="comment">// 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</span></span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">obj.<span class="title function_">toString</span>()   <span class="comment">// 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</span></span><br></pre></td></tr></table></figure><p>在 <a href="https://www.runoob.com/jsref/jsref-obj-date.html">Date 方法</a> 章节中，你可以查看更多关于日期转换为字符串的函数：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getDate()</td><td align="left">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td></tr><tr><td align="left">getDay()</td><td align="left">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td align="left">getFullYear()</td><td align="left">从 Date 对象以四位数字返回年份。</td></tr><tr><td align="left">getHours()</td><td align="left">返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="left">getMilliseconds()</td><td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="left">getMinutes()</td><td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="left">getMonth()</td><td align="left">从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="left">getSeconds()</td><td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td align="left">getTime()</td><td align="left">返回 1970 年 1 月 1 日至今的毫秒数。</td></tr></tbody></table></li><li><p><strong>将字符串转换为数字</strong></p><p>全局方法 <strong>Number()</strong> 可以将字符串转换为数字。字符串包含数字(如 “3.14”) 转换为数字 (如 3.14).空字符串转换为 0。其他的字符串会转换为 NaN (不是个数字)。</p><table><thead><tr><th>parseFloat()</th><th>解析一个字符串，并返回一个浮点数。</th></tr></thead><tbody><tr><td>parseInt()</td><td>解析一个字符串，并返回一个整数。</td></tr></tbody></table></li><li><p><strong>将日期转换为数字</strong></p><p>全局方法 <strong>Number()</strong> 可将日期转换为数字(时间戳)。日期方法 <strong>getTime()</strong> 也有相同的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="title class_">Number</span>(d)          <span class="comment">// 返回 1404568027739</span></span><br><span class="line">d = <span class="keyword">new</span> <span class="title class_">Date</span>();d.<span class="title function_">getTime</span>()        <span class="comment">// 返回 1404568027739</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自动转换类型</strong></p><p>当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> + <span class="literal">null</span>    <span class="comment">// 返回 5         </span></span><br><span class="line"> <span class="literal">null</span> 转换为 <span class="number">0</span><span class="string">&quot;5&quot;</span> + <span class="literal">null</span>  <span class="comment">// 返回&quot;5null&quot;   </span></span><br><span class="line"> <span class="literal">null</span> 转换为 <span class="string">&quot;null&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span> + <span class="number">1</span>     <span class="comment">// 返回 &quot;51&quot;      </span></span><br><span class="line"> <span class="number">1</span> 转换为 <span class="string">&quot;1&quot;</span>  </span><br><span class="line"><span class="string">&quot;5&quot;</span> - <span class="number">1</span>     <span class="comment">// 返回 4         </span></span><br><span class="line"> <span class="string">&quot;5&quot;</span> 转换为 <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>一元运算符 +</p><p><strong>Operator +</strong> 可用于将变量转换为数字：如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">&quot;5&quot;</span>;   <span class="comment">// y 是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> x = + y;   <span class="comment">// x 是一个数字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">&quot;John&quot;</span>;  <span class="comment">// y 是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> x = + y;   <span class="comment">// x 是一个数字 (NaN)</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h3 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="&#x3D;&#x3D;正则表达式&#x3D;&#x3D;"></a>&#x3D;&#x3D;正则表达式&#x3D;&#x3D;</h4><ol><li><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// /正则表达式主体/修饰符(可选)</span></span><br><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/runoob/i</span></span><br></pre></td></tr></table></figure></li><li><p>字符串方法</p><p><strong>search()</strong> 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p><p><strong>replace()</strong> 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Visit Runoob!&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> n = str.<span class="title function_">search</span>(<span class="string">&quot;Runoob&quot;</span>);  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>; </span><br><span class="line"><span class="keyword">var</span> txt = str.<span class="title function_">replace</span>(<span class="regexp">/microsoft/i</span>,<span class="string">&quot;Runoob&quot;</span>); <span class="comment">// 替换为Visit Runoob! </span></span><br><span class="line"><span class="comment">// 使用字符串作为参数</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>; </span><br><span class="line"><span class="keyword">var</span> txt = str.<span class="title function_">replace</span>(<span class="string">&quot;Microsoft&quot;</span>,<span class="string">&quot;Runoob&quot;</span>);</span><br></pre></td></tr></table></figure><p>正则表达式参数可用在以上方法中 (替代字符串参数)。<br>正则表达式使得搜索功能更加强大(如实例中不区分大小写)。</p></li><li><p>修饰符</p><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">执行对大小写不敏感的匹配。</td></tr><tr><td align="left">g</td><td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="left">m</td><td align="left">执行多行匹配。</td></tr></tbody></table></li><li><p>正则表达式模式</p><p>方括号用于查找某个范围内的字符：</p><table><thead><tr><th align="left">表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[abc]</td><td align="left">查找方括号之间的任何字符。</td></tr><tr><td align="left">[0-9]</td><td align="left">查找任何从 0 至 9 的数字。</td></tr><tr><td align="left">(x|y)</td><td align="left">查找任何以 | 分隔的选项。</td></tr></tbody></table></li><li><p>元字符是拥有特殊含义的字符：</p><table><thead><tr><th align="left">元字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\d</td><td align="left">查找数字。</td></tr><tr><td align="left">\s</td><td align="left">查找空白字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配单词边界。</td></tr><tr><td align="left">\uxxxx</td><td align="left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table></li><li><p>量词:</p><table><thead><tr><th align="left">量词</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">n+</td><td align="left">匹配任何包含至少一个 <em>n</em> 的字符串。</td></tr><tr><td align="left">n*</td><td align="left">匹配任何包含零个或多个 <em>n</em> 的字符串。</td></tr><tr><td align="left">n?</td><td align="left">匹配任何包含零个或一个 <em>n</em> 的字符串。</td></tr></tbody></table></li><li><p>正则表达式方法 </p><ul><li><p><strong>test()</strong></p><p>test() 方法是一个正则表达式方法。</p><p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p></li><li><p><strong>exec()</strong></p><p>exec() 方法是一个正则表达式方法。</p><p>exec() 方法用于检索字符串中的正则表达式的匹配。</p><p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p></li></ul></li></ol><hr><h4 id="JS错误"><a href="#JS错误" class="headerlink" title="JS错误"></a>JS错误</h4><ol><li><p><strong>语法</strong></p><p><strong>try</strong> 语句测试代码块的错误。</p><p><strong>catch</strong> 语句处理错误。</p><p><strong>throw</strong> 语句创建自定义错误。</p><p><strong>finally</strong> 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message, x;</span><br><span class="line">  message = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p01&quot;</span>);</span><br><span class="line">  message.<span class="property">innerHTML</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&quot;&quot;</span>) <span class="keyword">throw</span> <span class="string">&quot;值是空的&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(x)) <span class="keyword">throw</span> <span class="string">&quot;值不是一个数字&quot;</span>;</span><br><span class="line">    x = <span class="title class_">Number</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">10</span>) <span class="keyword">throw</span> <span class="string">&quot;太大&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">5</span>) <span class="keyword">throw</span> <span class="string">&quot;太小&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    message.<span class="property">innerHTML</span> = <span class="string">&quot;错误: &quot;</span> + err + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="JS调试"><a href="#JS调试" class="headerlink" title="JS调试"></a>JS调试</h4><p><strong>设置断点</strong></p><p>在调试窗口中，你可以设置 JavaScript 代码的断点。</p><p>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。</p><p>在检查完毕后，可以重新执行代码（如播放按钮）。</p><hr><p><strong>debugger 关键字</strong></p><p><strong>debugger</strong> 关键字用于停止执行 JavaScript，并调用调试函数。</p><p>这个关键字与在调试工具中设置断点的效果是一样的。</p><p>如果没有调试可用，debugger 语句将无法工作。</p><p>开启 debugger ，代码在第三行前停止执行。</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">15</span> * <span class="number">5</span>; <span class="keyword">debugger</span>; <span class="variable language_">document</span>.<span class="title function_">getElementbyId</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = x;</span><br></pre></td></tr></table></figure><hr><h4 id="JS-声明提升"><a href="#JS-声明提升" class="headerlink" title="JS 声明提升"></a>JS 声明提升</h4><p><strong>JavaScript 声明提升</strong></p><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p><p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p><p><strong>JavaScript 初始化不会提升</strong></p><p>JavaScript 只有声明的变量会提升，初始化的不会。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"></span><br><span class="line">elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 查找元素 </span></span><br><span class="line">elem.<span class="property">innerHTML</span> = x + <span class="string">&quot; &quot;</span> + y;           <span class="comment">// 显示 x 和 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span>; <span class="comment">// 初始化 y</span></span><br><span class="line"><span class="comment">// 输出undefined，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。</span></span><br></pre></td></tr></table></figure><hr><h4 id="JS严格模式"><a href="#JS严格模式" class="headerlink" title="JS严格模式"></a>JS严格模式</h4><ol><li><p><strong>使用 “use strict” 指令</strong></p><p>“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p><p>“use strict” 的目的是指定代码在严格条件下执行。严格模式下你不能使用未声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span> 指令在 <span class="title class_">JavaScript</span> <span class="number">1.8</span><span class="number">.5</span> (<span class="title class_">ECMAScript5</span>) 中新增。它不是一条语句，但是是一个字面量表达式，在 <span class="title class_">JavaScript</span> 旧版本中会被忽略。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span> 的目的是指定代码在严格条件下执行。严格模式下你不能使用未声明的变量。</span><br></pre></td></tr></table></figure></li><li><p><strong>严格模式的限制</strong></p><p>不允许使用未声明的变量：</p><p>不允许删除变量或对象</p><p>不允许删除函数。</p><p>不允许变量重名:</p><p>不允许使用八进制:</p><p>不允许使用转义字符:</p><p>不允许对只读属性赋值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = \<span class="number">010</span>;            <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;x&quot;</span>, &#123;<span class="attr">value</span>:<span class="number">0</span>, <span class="attr">writable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">3.14</span>;            <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许对一个使用getter方法读取的属性进行赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">x</span>() </span><br><span class="line">    &#123;<span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">3.14</span>;            <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许删除一个不允许删除的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>变量名不能使用 “eval” 字符串:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">3.14</span>;     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>变量名不能使用 “arguments” 字符串:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">arguments</span> = <span class="number">3.14</span>;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许使用以下这种语句:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">with</span> (<span class="title class_">Math</span>)&#123;x = <span class="title function_">cos</span>(<span class="number">2</span>)&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>由于一些安全原因，在作用域 eval() 创建的变量不能被调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span> (<span class="string">&quot;var x = 2&quot;</span>);</span><br><span class="line">alert (x);        <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>禁止this关键字指向全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span></span><br></pre></td></tr></table></figure><p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">f</span>();<span class="comment">// 报错，this未定义</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="浮点型数据使用注意事项"><a href="#浮点型数据使用注意事项" class="headerlink" title="浮点型数据使用注意事项"></a>浮点型数据使用注意事项</h4><p>JavaScript 中的所有数据都是以 64 位<strong>浮点型数据(float)</strong> 来存储。</p><p>所有的编程语言，包括 JavaScript，对浮点型数据的精确度都很难确定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">var</span> z = x + y      <span class="comment">// z 的结果为 0.30000000000000004</span></span><br><span class="line"><span class="keyword">if</span> (z == <span class="number">0.3</span>)      <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure><p>为解决以上问题，可以用整数的乘除法来解决：</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z = (x * <span class="number">10</span> + y * <span class="number">10</span>) / <span class="number">10</span>;    <span class="comment">// z 的结果为 0.3</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://www.runoob.com/w3cnote/js-precision-problem-and-solution.html">JavaScript 中精度问题以及解决方案</a></p><hr><h4 id="JS-表单验证API"><a href="#JS-表单验证API" class="headerlink" title="JS 表单验证API"></a>JS 表单验证API</h4><ol><li><p><strong>约束验证 DOM 方法</strong></p><table><thead><tr><th align="left">Property</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">checkValidity()</td><td align="left">如果 input 元素中的数据是合法的返回 true，否则返回 false。</td></tr><tr><td align="left">setCustomValidity()</td><td align="left">设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。使用 setCustomValidity 设置了自定义提示后，validity.customError 就会变成 true，checkValidity 总是会返回 false。如果要重新判断需要取消自定义提示，方式如下：<code>setCustomValidity(&#39;&#39;)  setCustomValidity(null)  setCustomValidity(undefined)</code></td></tr></tbody></table></li><li><p><strong>约束验证 DOM 属性</strong></p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">validity</td><td align="left">布尔属性值，返回 input 输入值是否合法</td></tr><tr><td align="left">validationMessage</td><td align="left">浏览器错误提示信息</td></tr><tr><td align="left">willValidate</td><td align="left">指定 input 是否需要验证</td></tr></tbody></table></li><li><p><strong>Validity 属性</strong></p><p>input 元素的 <strong>validity 属性</strong>包含一系列关于 validity 数据属性:</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">customError</td><td align="left">设置为 true, 如果设置了自定义的 validity 信息。</td></tr><tr><td align="left">patternMismatch</td><td align="left">设置为 true, 如果元素的值不匹配它的模式属性。</td></tr><tr><td align="left">rangeOverflow</td><td align="left">设置为 true, 如果元素的值大于设置的最大值。</td></tr><tr><td align="left">rangeUnderflow</td><td align="left">设置为 true, 如果元素的值小于它的最小值。</td></tr><tr><td align="left">stepMismatch</td><td align="left">设置为 true, 如果元素的值不是按照规定的 step 属性设置。</td></tr><tr><td align="left">tooLong</td><td align="left">设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。</td></tr><tr><td align="left">typeMismatch</td><td align="left">设置为 true, 如果元素的值不是预期相匹配的类型。</td></tr><tr><td align="left">valueMissing</td><td align="left">设置为 true，如果元素 (required 属性) 没有值。</td></tr><tr><td align="left">valid</td><td align="left">设置为 true，如果元素的值是合法的。</td></tr></tbody></table></li></ol><hr><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>面向对象语言中 this 表示当前对象的一个引用。</p><p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p><ul><li>在方法中，this 表示该方法所属的对象。</li><li>如果单独使用，this 表示全局对象。</li><li>在函数中，this 表示全局对象。</li><li>在函数中，在严格模式下，this 是未定义的(undefined)。</li><li>在事件中，this 表示接收事件的元素。</li><li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li></ul><p><strong>显式函数绑定</strong></p><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, <strong>this</strong> 将指向 person2, 即便它是 person1 的方法：</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.<span class="property">fullName</span>.<span class="title function_">call</span>(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br></pre></td></tr></table></figure><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/js/javascript-json-parse.html">JSON.parse()</a></td><td align="left">用于将一个 JSON 字符串转换为 JavaScript 对象。</td></tr><tr><td align="left"><a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify()</a></td><td align="left">用于将 JavaScript 值转换为 JSON 字符串。</td></tr></tbody></table><hr><h4 id="JS异步编程"><a href="#JS异步编程" class="headerlink" title="JS异步编程"></a>JS异步编程</h4><ol><li><p>异步（Asynchronous, async）是与同步（Synchronous, sync）相对的概念。同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效率更高。</p><p><img src="/.fun//async-sync.png" alt="async-sync"></p><p>我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。</p><p>为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。</p></li><li><p><strong>回调函数</strong></p><p>回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo1&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;RUNOOB-1!&quot;</span>;  <span class="comment">// 三秒后子线程执行</span></span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo2&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;RUNOOB-2!&quot;</span>;      <span class="comment">// 主线程先执行</span></span><br></pre></td></tr></table></figure></li><li><p><strong>异步Ajax</strong></p><p>除了 setTimeout 函数以外，异步回调广泛应用于 AJAX 编程。有关于 AJAX 详细请参见：<a href="https://www.runoob.com/ajax/ajax-tutorial.html">https://www.runoob.com/ajax/ajax-tutorial.html</a></p><p>XMLHttpRequest 常常用于请求来自远程服务器上的 XML 或 JSON 数据。一个标准的 XMLHttpRequest 对象往往包含多个回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"> </span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 输出接收到的文字数据</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>=xhr.<span class="property">responseText</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;请求出错&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发送异步 GET 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.runoob.com/try/ajax/ajax_info.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p><ol><li><p>构造 Promise</p><p>现在我们新建一个 Promise 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Promise 的构造函数</strong></p><p>Promise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数。</p><p>Promise 构造函数接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject，分别表示 Promise 成功和失败的状态。</p><p>起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。</p><p>Promise 构造函数返回一个 Promise 对象，该对象具有以下几个方法：</p><ul><li>then：用于处理 Promise 成功状态的回调函数。</li><li>catch：用于处理 Promise 失败状态的回调函数。</li><li>finally：无论 Promise 是成功还是失败，都会执行的回调函数。</li></ul><p>下面是一个使用 Promise 构造函数创建 Promise 对象的例子：</p><p>当 Promise 被构造时，起始函数会被同步执行：</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>常见问题</p><p><strong>Q: 除了 then 块以外，其它两种块能否多次使用？</strong></p><p>A: 可以，finally 与 then 一样会按顺序执行，但是 catch 块只会执行第一个，除非 catch 块里有异常。所以最好只安排一个 catch 和 finally 块。</p><p><strong>Q: then 块如何中断？</strong></p><p>A: then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。</p><p><strong>Q: Promise 是一种将异步转换为同步的方法吗？</strong></p><p>A: 完全不是。Promise 只不过是一种更良好的编程风格。</p><p><strong>Q: 什么时候我们需要再写一个 then 而不是在当前的 then 接着编程？</strong></p><p>A: 当你又需要调用一个异步任务的时候。</p></li><li><p><strong>异步函数</strong></p><p>异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">print</span>(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">print</span>(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以将这段代码变得更好看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyncFunc</span>();</span><br></pre></td></tr></table></figure><p>处理异常的机制将用 try-catch 块实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;            </span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;Some error&quot;</span>; <span class="comment">// 或者 reject(&quot;Some error&quot;)        </span></span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);        <span class="comment">// 会输出 Some error    </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>();   </span><br></pre></td></tr></table></figure><p>如果 Promise 有一个正常的返回值，await 语句也会返回它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;Return value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyncFunc</span>();   <span class="comment">// Return value</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="JS函数定义"><a href="#JS函数定义" class="headerlink" title="JS函数定义"></a>JS函数定义</h4><ol><li><p><strong>函数声明</strong></p><p>在之前的教程中，你已经了解了函数声明的语法 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function functionName(parameters) &#123;</span><br><span class="line">  执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数表达式</strong></p><p>JavaScript 函数可以通过一个表达式定义。</p></li><li><p><strong>Function() 构造函数</strong></p><p>在以上实例中，我们了解到函数通过关键字 <strong>function</strong> 定义。</p><p>函数同样可以通过内置的 JavaScript 函数构造器（Function()）定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;return a * b&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">myFunction</span>(<span class="number">4</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>实际上，你不必使用构造函数。上面实例可以写成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;<span class="keyword">return</span> a * b&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">myFunction</span>(<span class="number">4</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>在 JavaScript 中，很多时候，你需要避免使用 <strong>new</strong> 关键字。</th></tr></thead></table></li><li><p><strong>函数提升（Hoisting）</strong></p><p>在之前的教程中我们已经了解了 “hoisting(提升)”。</p><p>提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的行为。</p><p>提升（Hoisting）应用在变量的声明与函数的声明。</p><p>因此，函数可以在声明之前调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">myFunction</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>自调用函数</strong></p><p>函数表达式可以 “自调用”。自调用表达式会自动调用。如果表达式后面紧跟 () ，则会自动调用。不能自调用声明的函数。通过添加括号，来说明它是一个函数表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&quot;Hello!!&quot;</span>;   <span class="comment">// 我将调用自己</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>以上函数实际上是一个 <strong>匿名自我调用的函数</strong> (没有函数名)。</p></li><li><p><strong>箭头函数</strong></p><p>ES6 新增了箭头函数。箭头函数表达式的语法比普通函数表达式更简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数<span class="number">1</span> =&gt; &#123; 函数声明 &#125;     <span class="comment">// 一个参数</span></span><br><span class="line">() =&gt; &#123;<span class="keyword">return</span> 表达式;&#125;   <span class="comment">// 没有参数</span></span><br><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, …, 参数N) =&gt; 表达式(单一)</span><br><span class="line"><span class="comment">// 相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;</span></span><br></pre></td></tr></table></figure><p>有的箭头函数都没有自己的 <strong>this</strong>。 不适合定义一个 <strong>对象的方法</strong>。</p><p>当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的。</p><p>箭头函数是不能提升的，所以需要在使用之前定义。</p><p>使用 <strong>const</strong> 比使用 <strong>var</strong> 更安全，因为函数表达式始终是一个常量。</p><p>如果函数部分只是一个语句，则可以省略 return 关键字和大括号 {}，这样做是一个比较好的习惯</p></li></ol><hr><h4 id="JS函数参数"><a href="#JS函数参数" class="headerlink" title="JS函数参数"></a>JS函数参数</h4><ol><li><p>arguments 对象</p><p>JavaScript 函数有个内置的对象 arguments 对象。</p><p>arguments 对象包含了函数调用的参数数组。</p><p>通过这种方式你可以很方便的找到最大的一个参数的值：</p></li><li><p><strong>通过值传递参数</strong></p><p>在函数中调用的参数是函数的隐式参数。</p><p>JavaScript 隐式参数通过值来传递：函数仅仅只是获取值。</p><p>如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）。</p><p>隐式参数的改变在函数外是不可见的。</p></li><li><p>通过对象传递参数</p><p>在JavaScript中，可以引用对象的值。</p><p>因此我们在函数内部修改对象的属性就会修改其初始的值。</p><p>修改对象属性可作用于函数外部（全局变量）。</p><p>修改对象属性在函数外是可见的</p></li><li><p>对arguments的延申：</p><p>其实Javascript并没有重载函数的功能，但是Arguments对象能够模拟重载。</p><p>Javascrip中每个函数都会有一个Arguments对象实例arguments</p><p>它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。</p><p>arguments.length为函数实参个数</p><p>arguments.callee引用函数自身。</p></li></ol><h4 id="JS函数调用"><a href="#JS函数调用" class="headerlink" title="JS函数调用"></a>JS函数调用</h4><p><strong>JavaScript 函数调用</strong></p><p>JavaScript 函数有 4 种调用方式。</p><p>每种方式的不同在于 <strong>this</strong> 的初始化。</p><p><strong>this 关键字</strong></p><p>一般而言，在Javascript中，this指向函数执行时的当前对象。</p><ol><li><p><strong>作为一个函数调用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">myFunction</span>(<span class="number">10</span>, <span class="number">2</span>);           <span class="comment">// myFunction(10, 2) 返回 20</span></span><br></pre></td></tr></table></figure><p>以上函数不属于任何对象。但是在 JavaScript 中它始终是默认的全局对象。</p><p>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面。</p><p>在浏览器中的页面对象是浏览器窗口(window 对象)。以上函数会自动变为 window 对象的函数。</p></li><li><p><strong>函数作为方法调用</strong></p><p>在 JavaScript 中你可以将函数定义为对象的方法。</p><p>以下实例创建了一个对象 (<strong>myObject</strong>), 对象有两个属性 (<strong>firstName</strong> 和 <strong>lastName</strong>), 及一个方法 (<strong>fullName</strong>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    <span class="attr">fullName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.<span class="title function_">fullName</span>();          <span class="comment">// 返回 [object Object] (所有者对象)</span></span><br></pre></td></tr></table></figure><p><strong>fullName</strong> 方法是一个函数。函数属于对象。 <strong>myObject</strong> 是函数的所有者。</p><p><strong>this</strong>对象，拥有 JavaScript 代码。实例中 <strong>this</strong> 的值为 <strong>myObject</strong> 对象。</p></li><li><p><strong>使用构造函数调用函数</strong></p><p>如果函数调用前使用了 <strong>new</strong> 关键字, 则是调用了构造函数。</p><p>这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数: </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">arg1, arg2</span>) &#123;    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = arg1;    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span>  = arg2; </span><br><span class="line">&#125;  <span class="comment">// This creates a new object </span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title function_">myFunction</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Doe&quot;</span>); </span><br><span class="line">x.<span class="property">firstName</span>;                             <span class="comment">// 返回 &quot;John&quot;</span></span><br></pre></td></tr></table></figure><p>构造函数的调用会创建一个新的对象。新对象会继承构造函数的属性和方法。</p><table><thead><tr><th></th><th>构造函数中 <strong>this</strong> 关键字没有任何的值。 <strong>this</strong> 的值在函数调用实例化对象(new object)时创建。</th></tr></thead></table></li><li><p>作为函数方法调用函数<br>在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。</p><p>call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">myObject = myFunction.<span class="title function_">call</span>(myObject, <span class="number">10</span>, <span class="number">2</span>);     <span class="comment">// 返回 20</span></span><br><span class="line"></span><br><span class="line">myArray = [<span class="number">10</span>, <span class="number">2</span>];</span><br><span class="line">myObject = myFunction.<span class="title function_">apply</span>(myObject, myArray);  <span class="comment">// 返回 20</span></span><br></pre></td></tr></table></figure><p>两个方法都使用了对象本身作为第一个参数。 两者的区别在于第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。</p><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 <strong>this</strong> 的值， 即使该参数不是一个对象。</p><p>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p><table><thead><tr><th></th><th>通过 call() 或 apply() 方法你可以设置 <strong>this</strong> 的值, 且作为已存在对象的新方法调用。</th></tr></thead></table></li><li><p>结合本节知识点分享一段有趣的代码。</p><p>获取当前页面所有图片的 url:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].<span class="property">map</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>), <span class="keyword">function</span> (<span class="params">img</span>)&#123; <span class="keyword">return</span> img.<span class="property">src</span>;&#125;)</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="JS闭包"><a href="#JS闭包" class="headerlink" title="&#x3D;&#x3D;JS闭包&#x3D;&#x3D;"></a>&#x3D;&#x3D;JS闭包&#x3D;&#x3D;</h4><p>JavaScript 变量可以是局部变量或全局变量。私有变量可以用到闭包。</p><p>函数可以访问由函数内部定义的变量，函数也可以访问函数外部定义的变量，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">4</span>;<span class="comment">// a 为局部变量，局部变量只能用于定义它函数内部。对于其他的函数或脚本代码是不可用的。</span></span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;<span class="comment">// a为全局变量，在web页面中全局变量属于 window 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>变量生命周期</strong></p><p>全局变量的作用域是全局性的，即在整个JavaScript程序中，全局变量处处都在。</p><p>而在函数内部声明的变量，只在函数内部起作用。这些变量是局部变量，作用域是局部性的；函数的参数也是局部性的，只在函数内部起作用。</p></li><li><p><strong>计数器困境</strong></p><p>设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。</p><p>你可以使用全局变量，函数设置计数器递增：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;   </span><br><span class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="title function_">add</span>(); <span class="title function_">add</span>(); <span class="title function_">add</span>();  <span class="comment">// 计数器现在为 3</span></span><br></pre></td></tr></table></figure><p>计数器数值在执行 add() 函数时发生变化。</p><p>但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数。</p><p>如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">add</span>();<span class="title function_">add</span>();<span class="title function_">add</span>();  <span class="comment">// 输出都是1</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p><strong>JavaScript 内嵌函数</strong></p><p>所有函数都能访问全局变量。 </p><p>实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。</p><p>JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。</p><p>该实例中，内嵌函数 <strong>plus()</strong> 可以访问父函数的 <strong>counter</strong> 变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">plus</span>(<span class="params"></span>) &#123;counter += <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="title function_">plus</span>();    </span><br><span class="line">    <span class="keyword">return</span> counter; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能在外部访问 <strong>plus()</strong> 函数，这样就能解决计数器的困境。</p><p>我们同样需要确保 <strong>counter &#x3D; 0</strong> 只执行一次。</p><p><strong>我们需要闭包。</strong></p></li><li><p>&#x3D;&#x3D;JavaScript 闭包&#x3D;&#x3D;</p><p>还记得函数自我调用吗？该函数会做什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"> </span><br><span class="line"><span class="title function_">add</span>();<span class="title function_">add</span>();<span class="title function_">add</span>();<span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure><p><strong>实例解析</strong></p><p>变量 <strong>add</strong> 指定了函数自我调用的返回字值。</p><p>自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。</p><p>add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。</p><p>这个叫作 JavaScript <strong>闭包。</strong>它使得函数拥有私有变量变成可能。</p><p>计数器受匿名函数的作用域保护，只能通过 add 方法修改。</p><table><thead><tr><th></th><th>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。</th></tr></thead></table></li></ol><h4 id="JS类"><a href="#JS类" class="headerlink" title="JS类"></a>JS类</h4><p><strong>类方法</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/js/jsref-constructor-class.html">constructor()</a></td><td align="left">构造函数，用于创建和初始化类</td></tr></tbody></table><p><strong>类关键字</strong></p><table><thead><tr><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/js/jsref-class-extends.html">extends</a></td><td align="left">继承一个类</td></tr><tr><td align="left"><a href="https://www.runoob.com/js/jsref-class-static.html">static</a></td><td align="left">在类中定义一个静态方法</td></tr><tr><td align="left"><a href="https://www.runoob.com/js/jsref-class-super.html">super</a></td><td align="left">调用父类的构造方法</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Runoob</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">age</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x - <span class="variable language_">this</span>.<span class="property">year</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">let</span> year = date.<span class="title function_">getFullYear</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> runoob = <span class="keyword">new</span> <span class="title class_">Runoob</span>(<span class="string">&quot;菜鸟教程&quot;</span>, <span class="number">2020</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>=</span><br><span class="line"><span class="string">&quot;菜鸟教程 &quot;</span> + runoob.<span class="title function_">age</span>(year) + <span class="string">&quot; 岁了。&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="三、高阶"><a href="#三、高阶" class="headerlink" title="三、高阶"></a>三、高阶</h3><h4 id="JS-I-O"><a href="#JS-I-O" class="headerlink" title="JS I&#x2F;O"></a>JS I&#x2F;O</h4><ol><li><p><code>console.log</code>添加显示样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%chello&#x27;</span>, <span class="string">&#x27;font-size:20px&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们用 IIFE 封装下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> _log = <span class="variable language_">console</span>.<span class="property">log</span>;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="property">log</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="title function_">typeof</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]) != <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="title function_">typeof</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]) != <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">1</span>) &#123;</span><br><span class="line">               _log.<span class="title function_">call</span>(<span class="variable language_">console</span>, <span class="string">&#x27;%c&#x27;</span> + <span class="variable language_">arguments</span>[<span class="number">0</span>], <span class="string">&quot;text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em&quot;</span>)</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               _log.<span class="title function_">call</span>(<span class="variable language_">console</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)()</span><br></pre></td></tr></table></figure><p>代码的意思是如果 console 只有一个参数，并且不是函数或者对象就用我们定义的样式，否则用 console 的默认输入。然后用油猴之类的插件在页面加载时就加载这个函数，就可以告别原来无聊的调试了，当然你也可以写一个样式库，写一个随机函数，这样每次 console 都会有惊喜了。</p></li><li><p>解决文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;winTest()&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">winTest</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> txt1 = <span class="string">&quot;This is a new window.&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> txt2 = <span class="string">&quot;This is a test.&quot;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">open</span>(<span class="string">&quot;text/html&quot;</span>,<span class="string">&quot;replace&quot;</span>);<span class="comment">//加上</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">writeln</span>(txt1);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(txt2);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">close</span>();<span class="comment">//加上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击 “按钮” 后页面显示结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">This</span> is a <span class="keyword">new</span> <span class="variable language_">window</span>. <span class="title class_">This</span> is a test.</span><br></pre></td></tr></table></figure><p><strong>注：</strong>该方法将关闭 open() 方法打开的文档流，并强制地显示出所有缓存的输出内容。如果您使用 write() 方法动态地输出一个文档，必须记住当你这么做的时候要调用 close() 方法，以确保所有文档内容都能显示。document.write() 不会隐式调用 document.close() 方法的，否则例 2 中将不会有 <strong>This is a new window.</strong> 内容了</p><p>   一旦调用了close()，就不应该再次调用 write()，因为这会隐式地调用 open() 来擦除当前文档并开始一个新的文档。</p><p>   在载入页面后，浏览器输出流自动关闭。在此之后，比如延迟脚本 [setTimeout()] 或是 onload 执行的方法，任何一个对当前页面进行操作的 document.write()方法将打开—个新的输出流，它将清除当前页面内容(包括源文档的任何变量或值)。</p></li></ol><hr><h4 id="JS-注释"><a href="#JS-注释" class="headerlink" title="JS 注释"></a>JS 注释</h4><p>应用注释符号验证浏览器是否支持 JavaScript 脚本功能</p><p>如果用户不能确定浏览器是否支持JavaScript脚本，那么可以应用HTML提供的注释符号进行验证。HTML注释符号是以 <strong>&lt;–** 开始以 **–&gt;</strong> 结束的。如果在此注释符号内编写 JavaScrip t脚本，对于不支持 JavaScript 的浏览器，将会把编写的 JavaScript 脚本作为注释处理。</p><p>使用 JavaScript 脚本在页面中输出一个字符串，将 JavaScript 脚本编写在 HTML 注释中，如果浏览器支持 JavaScript 将输出此字符串，如果不支持将不输出此字符串，代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="comment">&lt;!--</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">document.write(&quot;您的浏览器支持JavaScript脚本!&quot;);</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">//--&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>注释行结尾处的两条斜杠 <strong>&#x2F;&#x2F;</strong> 是 JavaScript 注释符号。这可以避免 JavaScript 执行 <strong>–&gt;</strong> 标签。</p><hr><h4 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h4><ol><li><p><strong>基本类型的变量是存放在栈内存（Stack）里的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b;</span><br><span class="line">a = <span class="string">&quot;zyj&quot;</span>;</span><br><span class="line">b = a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);   <span class="comment">// zyj</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);   <span class="comment">// zyj</span></span><br><span class="line">a = <span class="string">&quot;呵呵&quot;</span>;       <span class="comment">// 改变 a 的值，并不影响 b 的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);   <span class="comment">// 呵呵</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);   <span class="comment">// zyj</span></span><br></pre></td></tr></table></figure><p>图解如下：栈内存中包括了变量的标识符和变量的值。</p><p><img src="/.fun//3834493100-57c3ff4a5dac7_articlex.png" alt="img"></p></li><li><p><strong>引用类型的值是保存在堆内存（Heap）中的对象（Object)</strong></p><p>引用类型的值是保存在堆内存（Heap）中的对象（Object）<br>与其他编程语言不同，JavaScript 不能直接操作对象的内存空间（堆内存）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">&quot;percy&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">b = a;</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&quot;zyj&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>);    <span class="comment">// zyj</span></span><br><span class="line">b.<span class="property">age</span> = <span class="number">22</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>);     <span class="comment">// 22</span></span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zyj&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图解如下：</p><ul><li><p>栈内存中保存了变量标识符和指向堆内存中该对象的指针</p></li><li><p>堆内存中保存了对象的内容</p></li></ul><p><img src="/.fun//3834493100-57c3ff4a5dac7_articlex.png" alt="3834493100-57c3ff4a5dac7_articlex"></p><p><img src="/.fun//3309698956-57c41a89cddc7_articlex.png" alt="3309698956-57c41a89cddc7_articlex"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习笔记 </category>
          
          <category> 前端 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面经-JS（二）</title>
      <link href="/2024/04/24/3SMY9WK/"/>
      <url>/2024/04/24/3SMY9WK/</url>
      
        <content type="html"><![CDATA[<h3 id="Q1：-如何判断-JavaScript-的数据类型"><a href="#Q1：-如何判断-JavaScript-的数据类型" class="headerlink" title="Q1： 如何判断 JavaScript 的数据类型"></a>Q1： 如何判断 JavaScript 的数据类型</h3><ol><li><p>**<code>typeof()</code> **</p><p>使用 <code>typeof</code> 只能判断基本数据类型, 如 number, string, boolean, symbol 和 undefined</p><p>对于数组、null、对象来说，其关系错综复杂，使用 typeof 都会统一返回 “object” 字符串。</p><p>要想区别对象、数组、函数单纯使用 <code>typeof</code> 是不行的，JavaScript中,通过<code>Object.prototype.toString</code> 方法，判断某个对象值属于哪种内置类型。</p></li><li><p>**<code>instanceof</code> **</p><p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 <code>object</code> 的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">D</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(o) === C.prototype</span></span><br><span class="line">o <span class="keyword">instanceof</span> D; <span class="comment">// false，因为 D.prototype 不在 o 的原型链上</span></span><br></pre></td></tr></table></figure><p>需要注意的是，如果表达式 <code>obj instanceof Foo</code> 返回 <code>true</code>，则并不意味着该表达式会永远返回 <code>true</code>，因为 <code>Foo.prototype</code> 属性的值有可能会改变，改变之后的值很有可能不存在于 <code>obj</code> 的原型链上，这时原表达式的值就会成为 <code>false</code>。</p><p><strong>注意:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">//false</span></span><br><span class="line"><span class="title class_">String</span> <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="title class_">Foo</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Foo</span> <span class="keyword">instanceof</span> <span class="title class_">Foo</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Object.prototype.toString.call()</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">123</span>));    <span class="comment">//[object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;123&#x27;</span>));    <span class="comment">//[object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>));    <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>));    <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;));    <span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]));    <span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));    <span class="comment">//[object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>));    <span class="comment">//[[object Null]]</span></span><br></pre></td></tr></table></figure><p>在介绍<code>Object.prototype.toString</code>方法之前，我们先把<code>toString()</code>方法和<code>Object.prototype.toString.call()</code> 方法进行对比。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">//直接对一个数组调用toString()</span></span><br><span class="line">arr.<span class="title function_">toString</span>();<span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="comment">//通过 call 指定 arr 数组为Object.prototype对象中的toString方法的上下文</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr); <span class="comment">//&quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><p>数组重写了 <code>toString</code> 方法，所以直接调用数组 <code>arr</code> 上面的 <code>toString</code> 方法调用到的实际是重写后的方法，并不是 <code>Object.prototype</code> 中的 <code>toString</code> 方法。</p><p>而重写后的 <code>toString</code> 方法可以把对象转换成字符串，还可以把数值转换成不同进制的数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].<span class="title function_">toString</span>();<span class="comment">// &quot;1,2&quot;  得到字符串</span></span><br><span class="line"></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">2</span>);<span class="comment">//10进制转2进制 1010 ，如果1.toString(2)会报错，因为js会认为.是数字的小数点而不是调用符号</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意：</strong> 只有 <code>Object.prototype.toString.call(arr)</code> 可以用来判断数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr);<span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr);<span class="comment">// &#x27;1,2,3&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>本质：</strong></p><p>我们都知道js中的对象都继承自<code>Object</code>，所以当我们在某个对象上调用一个方法时，会先在该对象上进行查找，如果没找到则会进入对象的原型（也就是 <code>.prototype</code> ）进行查找，如果没找到，同样的也会进入对象原型的原型进行查找，直到找到或者进入原型链的顶端 <code>Object.prototype</code> 才会停止。</p><p>所以，当我们使用 <code>arr.toString()</code> 时，不能进行复杂数据类型的判断，因为它调用的是<code>Array.prototype.toString</code>，虽然<code>Array</code>也继承自<code>Object</code>，但js在<code>Array.prototype</code>上重写了<code>toString</code>，而我们通过 <code>toString.call(arr)</code> 实际上是通过原型链调用了 <code>Object.prototype.toString</code> 。</p></li></ol><h3 id="Q2：如何理解ES6中的-this"><a href="#Q2：如何理解ES6中的-this" class="headerlink" title="* Q2：如何理解ES6中的 this"></a>* Q2：如何理解ES6中的 <code>this</code></h3><p>我们常见的window属性和方法有 <code>alter</code>，<code>document</code>，<code>parseInt</code>，<code>setTimeout</code>，<code>setInterval</code>，<code>localtion</code> 等等，这些在默认的情况下是省略了window前缀的。（window.alter &#x3D; alter）。</p><ol><li><p>普通函数中的this</p><blockquote><p>this 永远指向 <strong>调用</strong> 包含 自己（this本身） 的 <strong>函数</strong> 对应的对象。</p></blockquote><p>也就是说，包含 this 的函数 只在乎是谁调用了它，跟在哪里进行的函数声明没有关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>函数在最外层直接运行，因为 <code>test()</code> 是被window对象调用的，所以这里的 <code>this.a</code> 对应的应该是<strong>全局变量（或者叫window变量）</strong>, 而不是test函数里的局部变量，由于在 window 对象中没有声明变量a，所以输出 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">&#x27;America&#x27;</span>,</span><br><span class="line">    show : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">show</span>(); <span class="comment">// America</span></span><br></pre></td></tr></table></figure><p>另一个题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">&#x27;America&#x27;</span>,</span><br><span class="line">    show : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = obj.<span class="title function_">show</span>(); <span class="comment">//运行了，返回了一个函数</span></span><br><span class="line"><span class="title function_">a</span>(); <span class="comment">// China</span></span><br></pre></td></tr></table></figure><p>此时， <code>a</code> 等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>使用场景</strong></p><ol><li><p>在一般函数方法中使用 this 指代全局对象</p></li><li><p>作为对象方法调用，this 指代上级对象</p></li></ol>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line">obj.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>作为构造函数调用，this 指向 new 出的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123; <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;China&#x27;</span>; &#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="property">name</span>); <span class="comment">//&#x27;China&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>apply, call 调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">name</span>);<span class="comment">// &#x27;animal&#x27;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>箭头函数中的this <strong>(还没搞懂)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">   <span class="attr">sayHello</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="title function_">sayHello</span>();<span class="comment">// 还是以为输出A ? 错啦，其实输出的是window</span></span><br></pre></td></tr></table></figure><p>箭头函数没有自己的this值，箭头函数中所使用的this来自于函数作用域链。</p><p>代码没有在任何函数中执行，而是在全局作用域中执行时，this的值就是global对象，对于浏览器来说，this就是window。</p><p>事实上, 箭头函数并不绑定 <code>this</code>、<code>arguments</code>、<code>super(ES6)</code>、抑或 <code>new.target(ES6)</code> 箭头函数不会绑定这些局部变量，这意味着所有涉及它们的引用，都会沿袭向上查找外层作用域链的方案来处理。</p><table><thead><tr><th><a href="https://blog.csdn.net/devincob/article/details/72628757">javascript中的关键字this_箭头函数中的this为什么不可以更改-CSDN博客</a></th></tr></thead></table></li></ol><h3 id="Q3：JS内置对象及方法"><a href="#Q3：JS内置对象及方法" class="headerlink" title="* Q3：JS内置对象及方法"></a>* Q3：JS内置对象及方法</h3><h4 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h4><ol><li><p>length </p></li><li><p><strong><code>join</code>:</strong> 将数组装换成字符串, 返回一个字符串</p></li><li><p>reverse</p></li><li><p><em><code>delete</code></em> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">//[undefined, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>delete删除之后数组长度不变，只是被删除元素被置为undefined了</p></li><li><p><strong>shift, pop, unshift, push</strong></p></li><li><p><code>concat</code> 连接数组</p></li><li><p><em><code>slice</code></em> 截取数组, 返回数组的一部分, 原数组不会改变</p></li><li><p><em>sort</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span> <span class="number">4</span>, <span class="number">5</span>,]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b <span class="comment">// 从小到大</span></span><br><span class="line">    <span class="comment">// return b-a // 从大到小</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>splice</code></strong> 插入, 删除, 替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">var</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;grey&quot;</span>];</span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> item = colors.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line"><span class="number">3</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item);      <span class="comment">//&quot;red&quot;</span></span><br><span class="line"><span class="number">4</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(colors);    <span class="comment">//[&quot;blue&quot;, &quot;grey&quot;]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><code>splice()</code></th><th>arg1: 开始位置</th><th>arg2: 删除项数</th><th>arg3: 替换内容</th></tr></thead></table></li><li><p><code>toLacaleString</code> 把数组转换成局部字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;21 Dec 1997 14:12:00 UTC&#x27;</span>)];</span><br><span class="line"><span class="keyword">const</span> localeString = array1.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en&#x27;</span>, &#123; <span class="attr">timeZone</span>: <span class="string">&#x27;UTC&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localeString);  <span class="comment">// &quot;1,a,12/21/1997, 2:12:00 PM&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>toString</strong> 返回字符串</p></li><li><p><strong>foEach</strong></p></li><li><p><code>every</code> : 判断所有元素是否都符合要求</p></li><li><p><strong><code>map</code></strong> 对元素进行重新组装形成新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line">    x.<span class="property">innerHTML</span> = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;<span class="keyword">return</span> v*<span class="number">2</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>filter</code> 过滤元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span> <span class="number">4</span>, <span class="number">5</span>,]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (item &gt; <span class="number">2</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr2 ) <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h4><ol><li><p>length 获取长度</p></li><li><p>toLowerCase、toUpperCase 大写小写</p></li><li><p><code>charAt(index)</code>  返回index位置的值或者 -1</p></li><li><p><code>substr(start,length)</code>、<code>substring(indexStart, indexEnd)</code></p><p>substr() 方法可在字符串中抽取从 <em>开始</em> 下标开始的指定数目的字符</p><p>zsubstring() 返回包含给定字符串的指定部分的新字符串</p></li><li><p><code>split</code> 方法用于把一个字符串分割成字符串数组。</p><blockquote><p>split(separator)<br>split(separator, limit)</p></blockquote><p>如果把空字符串 (‘’) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。</p></li><li><p>charCodeAt</p></li><li><p><code>concat</code></p></li><li><p>fromCharCode</p></li><li><p><code>indexOf</code> &#x2F; lastIndexOf 获得指定下标的字符，lastIndexOf 从后面开始遍历</p></li><li><p>localCompare</p></li><li><p>match </p><p><code>match(regexp)</code> 方法将字符串与正则表达式进行匹配。</p><p><strong>提示：</strong>如果搜索值为字符串，则转换为正则表达式。<code>match()</code> 方法返回包含匹配项的数组。如果未找到匹配项，则 <code>match()</code> 方法返回 <code>null</code>。</p></li><li><p><code>replace</code></p></li><li><p><code>search</code></p></li><li><p><code>slice</code></p><p>slice() 方法提取字符串的一部分，并将其作为新字符串返回，而不修改原始字符串。</p><blockquote><p>slice(indexStart)</p><p>slice(indexStart, indexEnd)</p></blockquote></li><li><p>toLocaleUpperCase &#x2F; toLocaeLowweCase</p></li><li><p>toString</p></li><li><p><code>valueOf</code></p><p>valueOf() 方法可返回 String 对象的原始值。</p><p><strong>注意：</strong> valueOf() 方法通常由 JavaScript 在后台自动进行调用，而不是显式地处于代码中。</p><blockquote><p><em>string</em>.valueOf()</p></blockquote></li></ol><h4 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h4><ol><li><p><strong>toFixed</strong>  把Number转换为字符串，并保留指定位数的小数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num.<span class="title function_">toFixed</span>(digits)</span><br></pre></td></tr></table></figure><p><code>digits</code>: 保留的小数位数。</p></li><li><p><strong>parseInt</strong> 解析一个字符串，并返回一个整数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(string[, radix])</span><br></pre></td></tr></table></figure><ul><li><code>string</code>: 要解析的字符串。</li><li><code>radix</code>：（可选）表示要解析的数字的基数，例如10代表十进制。</li></ul></li><li><p><code>toPrecision(digits)</code> 返回一个指定精度的数字。 </p></li><li><p><code>toExponential() </code>返回一个数字的指数形式的字符串，如：1.23e+2</p></li><li><p><code>八进制和十六进制</code></p><p>如果前缀为 0，则 JavaScript 会把数值常量解释为八进制数，如果前缀为 0 和 “x”，则解释为十六进制数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="number">0377</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">0xFF</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><img src="/.fun//lamp.jpg" alt="lamp"></th><th>绝不要在数字前面写零，除非您需要进行八进制转换。</th></tr></thead></table><p>默认情况下，JavaScript 数字为十进制显示。但是你可以使用 toString() 方法 输出16进制、8进制、2进制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myNumber=<span class="number">128</span>;</span><br><span class="line">myNumber.<span class="title function_">toString</span>(<span class="number">16</span>);  <span class="comment">// 返回 80</span></span><br><span class="line">myNumber.<span class="title function_">toString</span>(<span class="number">8</span>);  <span class="comment">// 返回 200</span></span><br><span class="line">myNumber.<span class="title function_">toString</span>(<span class="number">2</span>);  <span class="comment">// 返回 10000000</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><ol><li><p>初始化： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()<span class="comment">// Fri Apr 26 2024 16:09:30 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure><p>这将会创造一个指向当前时刻的 Date 对象。</p><p>参数为时间戳时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timestamp = <span class="number">1530826365</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(timestamp * <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// Fri Jul 06 2018 05:32:45 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure><p>如果我们传值为 0，我们将会得到一个表示 1970年1月1日的 JavaScript Date 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>如果我们传值一个字符串而不是数字，那么Date对象将会调用 <code>parse</code> 去确定你想传入的日期。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2018-07-22&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2018-07&#x27;</span>) <span class="comment">//July 1st 2018, 00:00:00</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2018&#x27;</span>) <span class="comment">//Jan 1st 2018, 00:00:00</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;07/22/2018&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2018/07/22&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2018/7/22&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;July 22, 2018&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;July 22, 2018 07:22:13&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2018-07-22 07:22:13&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2018-07-22T07:22:13&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;25 March, 2018&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;March 25 2018&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>Date.parse</code> 方法将会返回一个时间戳（以毫秒计）而不是 Date 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;2018&#x27;</span>) <span class="comment">//Jan 1st 2018, 00:00:00（译者注：意思同上）</span></span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;2018/07/22&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;July 22, 2018&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;July 22, 2018 07:22:13&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;2018-07-22 07:22:13&#x27;</span>)</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;2018-07-22T07:22:13&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>获取时间戳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br></pre></td></tr></table></figure><p>下面这种方式更加复杂：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br></pre></td></tr></table></figure></li><li><p>Date 转换及格式化</p><p>给定一个 Date 对象，会有许多种可以生成与该时间相关的字符串的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;July 22, 2018 07:22:13&#x27;</span>)</span><br><span class="line"></span><br><span class="line">date.<span class="title function_">toString</span>() <span class="comment">// &quot;Sun Jul 22 2018 07:22:13 GMT+0200 (Central European Summer Time)&quot;</span></span><br><span class="line">date.<span class="title function_">toTimeString</span>() <span class="comment">//&quot;07:22:13 GMT+0200 (Central European Summer Time)&quot;</span></span><br><span class="line">date.<span class="title function_">toUTCString</span>() <span class="comment">//&quot;Sun, 22 Jul 2018 05:22:13 GMT&quot;</span></span><br><span class="line">date.<span class="title function_">toDateString</span>() <span class="comment">//&quot;Sun Jul 22 2018&quot;</span></span><br><span class="line">date.<span class="title function_">toISOString</span>() <span class="comment">//&quot;2018-07-22T05:22:13.000Z&quot; (ISO 8601 format)</span></span><br><span class="line"></span><br><span class="line">date.<span class="title function_">toLocaleString</span>() <span class="comment">//&quot;22/07/2018, 07:22:13&quot;</span></span><br><span class="line">date.<span class="title function_">toLocaleTimeString</span>()<span class="comment">//&quot;07:22:13&quot;</span></span><br><span class="line">date.<span class="title function_">getTime</span>() <span class="comment">//1532236933000</span></span><br><span class="line">date.<span class="title function_">getTime</span>() <span class="comment">//1532236933000</span></span><br></pre></td></tr></table></figure></li><li><p>Date 对象的 get（获取）方法</p><p>一个 Date 对象会提供如下方法去查看它的值。这些值会取决于你计算机所处的时区。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;July 22 2018 07:22:13&#x27;</span>)</span><br><span class="line"></span><br><span class="line">date.<span class="title function_">getDate</span>() <span class="comment">//22</span></span><br><span class="line">date.<span class="title function_">getDay</span>() <span class="comment">//0（0 表示周日，1 表示周一...）</span></span><br><span class="line">date.<span class="title function_">getFullYear</span>() <span class="comment">//2018</span></span><br><span class="line">date.<span class="title function_">getMonth</span>() <span class="comment">//6（从 0 开始计）</span></span><br><span class="line">date.<span class="title function_">getHours</span>() <span class="comment">//7</span></span><br><span class="line">date.<span class="title function_">getMinutes</span>() <span class="comment">//22</span></span><br><span class="line">date.<span class="title function_">getSeconds</span>() <span class="comment">//13</span></span><br><span class="line">date.<span class="title function_">getTime</span>() <span class="comment">//1532236933000</span></span><br></pre></td></tr></table></figure><p>这儿还有一些相似的使用 UTC 时区的方法，它们会使用 UTC 时区而不是你所在的时区。</p></li><li><p>修改 Date</p><p>一个 Date 对象提供以下修改 Date 值的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;July 22, 2018 07:22:13&#x27;</span>)</span><br><span class="line"></span><br><span class="line">date.<span class="title function_">setDate</span>(newValue)</span><br><span class="line">date.<span class="title function_">setDay</span>(newValue)</span><br><span class="line">date.<span class="title function_">setFullYear</span>(newValue) <span class="comment">//note：不要使用 setYear()，它已经被废弃了</span></span><br><span class="line">date.<span class="title function_">setMonth</span>(newValue)</span><br><span class="line">date.<span class="title function_">setHours</span>(newValue)</span><br><span class="line">date.<span class="title function_">setMinutes</span>(newValue)</span><br><span class="line">date.<span class="title function_">setSeconds</span>(newValue)</span><br><span class="line">date.<span class="title function_">setTime</span>(newValue)</span><br></pre></td></tr></table></figure></li><li><p>题1 ：倒计时模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date1 = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"><span class="keyword">const</span> date2 = <span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;2024-04-22&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(date1 -date2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="title function_">getDate</span>()+ <span class="string">&quot;:&quot;</span> + d.<span class="title function_">getHours</span>() + <span class="string">&quot;:&quot;</span> + d.<span class="title function_">getMinutes</span>() + <span class="string">&quot;:&quot;</span> + d.<span class="title function_">getSeconds</span>() )</span><br></pre></td></tr></table></figure></li></ol><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><ul><li><code>Math.random()</code>     返回0到1之间的一个伪随机数（不包括1）。</li><li><code>Math.max(...values)</code>   返回一组数值中的最大值。</li><li><code>...values</code>: 要比较的数值。</li><li>Math.PI   求PI</li><li>Math.abs()    绝对值</li><li>Math.ceil()    向上取整</li><li><code>Math.floor()</code>    向下取整</li><li><code>Math.round()</code>    四舍五入</li><li><code>Math.pow(x, y)</code>  返回 x的y次方</li><li><code>Math.sqrt()</code>  返回平方根</li></ul><h3 id="Q4-Object对象和-prototype对象"><a href="#Q4-Object对象和-prototype对象" class="headerlink" title="Q4: Object对象和 prototype对象"></a>Q4: Object对象和 prototype对象</h3><h3 id="Q5：JS-的-new-操作符做了哪些事情？"><a href="#Q5：JS-的-new-操作符做了哪些事情？" class="headerlink" title="Q5：JS 的 new 操作符做了哪些事情？"></a>Q5：JS 的 new 操作符做了哪些事情？</h3><blockquote><p>作者：去追光<br>链接：<a href="https://juejin.cn/post/6968856664560648199">https://juejin.cn/post/6968856664560648199</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p><strong><code>new</code> 运算符创建一个用户定义的对象数据类型的实例或者具有构造函数内置对象的实例</strong>。</p><p>它进行的操作：</p><ul><li><p>首先创建一个新的空对象</p></li><li><p>然后将空对象的 <code>__proto__</code> 指向构造函数的原型</p><p>它将新生成的对象的 <code>__proto__</code> 属性赋值为构造函数的 <code>prototype</code> 属性，使得通过构造函数创建的所有对象可以共享相同的原型。这意味着同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的对象。</p></li><li><p>改变 <code>this</code> 的指向，指向空对象</p></li><li><p>对构造函数的返回值做判断，然后返回对应的值</p><ul><li>一般是返回第一步创建的空对象；但是当 <strong>构造函数有返回值时</strong> 则需要做判断再返回对应的值，是 <strong>对象类型则返回该对象</strong>，是 <strong>原始类型则返回第一步创建的空对象</strong>。</li></ul></li></ul><p>当验证 <code>this</code> 指向时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>())  <span class="comment">// Window&#123;...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Foo</span>())  <span class="comment">// 输出：Foo &#123; name: &#x27;张三&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>代码模拟构成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">Con, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个新的空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将这个空对象的__proto__指向构造函数的原型</span></span><br><span class="line">  <span class="comment">// obj.__proto__ = Con.prototype; </span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将this指向空对象</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, args);</span><br><span class="line">  <span class="comment">// 对构造函数返回值做判断，然后返回对应的值</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下构造函数是没有返回值的，但是作为函数，是可以有返回值的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> per = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="string">&#x27;你好，new&#x27;</span>);</span><br><span class="line"><span class="comment">// 当构造函数返回对象类型的数据时，会直接返回这个数据， new 操作符无效</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per); <span class="comment">// &#123;age: 22&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> per = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="string">&#x27;你好，new&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(per);  <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;十二点的程序员&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> per = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="string">&#x27;你好，new&#x27;</span>);</span><br><span class="line"><span class="comment">// 而当构造函数返回基础类型的数据，则会被忽略</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per); <span class="comment">// &#123;name: &quot;你好，new&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Q6-闭包"><a href="#Q6-闭包" class="headerlink" title="Q6: 闭包"></a>Q6: 闭包</h3><ol><li><p>闭包是什么<br>闭包是一个函数加上到创建函数的作用域的连接，闭包“关闭”了函数的自由变量。</p></li><li><p>闭包可以解决什么问题【闭包的优点】</p><ol><li>内部函数可以访问到外部函数的局部变量</li><li>闭包可以解决的问题: 典型是事件绑定中的同步和异步问题</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lis <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;1i&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;lis.<span class="property">length</span>;i++)&#123;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">lis[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>() <span class="comment">// Function foo()&#123;&#125;</span></span><br><span class="line"><span class="title function_">fun</span>()() <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p>闭包的缺点</p><ol><li><p>变量会驻留在内存中，造成内存损耗问题。<br>解决：把闭包的函数设置为null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">lis[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">    lis[i].<span class="property">onclick</span> = <span class="literal">null</span></span><br><span class="line">&#125;)(i)</span><br></pre></td></tr></table></figure></li><li><p>内存泄漏【ie】&#x3D;&gt;可说可不说，如果说一定要提到ie</p></li></ol></li></ol><h3 id="Q7-原型链"><a href="#Q7-原型链" class="headerlink" title="Q7: 原型链"></a>Q7: 原型链</h3><ol><li>原型解决的问题：JS 不含有继承，对象之间共享方法和属性</li><li>谁有原型<br>函数拥有：<code>prototype</code><br>对象拥有：<code>__proto__</code>.</li><li>对象查找属性或者方法的顺序<br>先在对象本身查找–&gt;构造函数中查找-&gt;对象的原型–〉构造函数的原型中–&gt;原型的原型</li><li>原型链<ol><li>是什么？：就是把原型串联起来</li><li>原型链的最顶端是 <code>null</code></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面经-JS（一）</title>
      <link href="/2024/04/23/31NKJTB/"/>
      <url>/2024/04/23/31NKJTB/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Q1-延迟加载的方法有哪些"><a href="#Q1-延迟加载的方法有哪些" class="headerlink" title="Q1: 延迟加载的方法有哪些"></a>Q1: 延迟加载的方法有哪些</h3><p><code>async</code>和<code>defer</code>属性都用于指定脚本的加载方式，将脚本与HTML文档的解析和渲染过程分离，以避免阻塞页面的呈现。因此，通过使用defer属性或async属性，可以优化页面加载性能，避免脚本阻塞文档的解析过程。</p><ol><li><p><code>aysnc</code><br>目的：不让页面等待脚本下载和执行，从而<strong>异步加载页面其他内容</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test2.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 这里放内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span>  </span><br></pre></td></tr></table></figure><p>当浏览器遇到带有 <code>async</code> 属性的脚本标签时，它会开始异步下载脚本，并在下载完成后立即执行。使用<code>async</code>属性时，脚本的执行顺序不受保证。如果有多个带有<code>async</code>属性的脚本，它们可能会以任意顺序执行，因此脚本之间的依赖关系需要谨慎处理。</p></li><li><p><code>defer</code>: 当浏览器遇到带有 <code>defer</code> 属性的脚本标签时，它会开始异步下载脚本，但会等到文档解析完成后再执行脚本。这意味着脚本的加载不会阻塞页面的呈现，但它们将按照它们在文档中的顺序执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test2.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 这里放内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span>  </span><br></pre></td></tr></table></figure><p>使用<code>defer</code>属性时，脚本的执行被延迟到文档解析完成之后，但在<code>DOMContentLoaded</code>事件触发之前。这使得脚本能够在文档完全解析之前对DOM进行操作。</p></li></ol><blockquote><p>需要注意的是，<code>async</code>和<code>defer</code>属性只适用于外部脚本（通过<code>src</code>属性引入的脚本），不适用于内联脚本（直接在HTML文件中编写的脚本）。也就是说，这些属性只对外部脚本起作用，而不会影响内联脚本的加载和执行方式。</p></blockquote><blockquote><p>不同之处在于，使用defer属性的脚本会按照它们在文档中出现的顺序执行，而使用async属性的脚本则会在加载完成后立即执行，不考虑它们在文档中的位置。</p></blockquote><ol start="3"><li><p>其他</p><ol><li><p>动态加载脚本（Dynamic Script）：<br>动态加载脚本是一种使用JavaScript在页面中插入一个新的<script>标签来加载脚本的方式。这种方式可以通过异步或延迟属性来控制脚本加载的方式。动态加载脚本最大的优点是可以根据页面的具体情况来加载所需的脚本，避免一次性加载过多的脚本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">async</span> = <span class="literal">true</span>; <span class="comment">// 或者 script.defer = true;</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;example.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure></li><li><p>按需加载脚本（Lazy Load Script）：<br>按需加载脚本是一种在特定时刻才加载脚本的方式，而不是在页面加载完成后立即加载。这种方式可以减少页面的初始加载体积，加快页面的加载速度，提升用户体验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = <span class="string">&#x27;example.js&#x27;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要的时候调用loadScript函数来加载脚本</span></span><br></pre></td></tr></table></figure></li><li><p>setTimeOut</p></li></ol></li></ol><h3 id="Q2-数据类型"><a href="#Q2-数据类型" class="headerlink" title="Q2: 数据类型"></a>Q2: 数据类型</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><p>基本类型: number, string, Boolean, null, undefined, symbol, bigInt </p><p>引用类型: object => function, array</p></blockquote><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><ol><li>字符串相加为连接字符串  <code>&#39;name&#39;+true</code>  //nametrue</li><li>布尔值跟数字相加得数字  <code>true + 1</code>  //2</li><li><code>undefined + 1</code> // NAN</li><li><code>typeof(NAN)</code>  //number</li><li><code>typeof(undefined)</code>  //undefined</li><li><code>typeof(null)</code>  // Object</li></ol><h3 id="Q3-null-和-undefined"><a href="#Q3-null-和-undefined" class="headerlink" title="Q3: null 和 undefined"></a>Q3: null 和 undefined</h3><ol><li><code>null</code> 和 <code>undefined</code> 都表示空,无值</li><li><code>null</code> 会被隐式转换成 0, 出现错误不易发现</li><li><code>undefined</code> 转换为 <code>NaN</code></li><li>typeof(null) 和 typeof(undefined)</li></ol><h3 id="Q4-和"><a href="#Q4-和" class="headerlink" title="Q4: "==" 和  "===""></a>Q4: "==" 和  "==="</h3><p><code>==</code> 判断值是否相等</p><ol><li><code>null</code> 和 <code>undefined</code></li><li>string 和 number, 会进行隐式转换, 把 <code>string</code> 转换成 <code>number</code></li><li>boolean 和 number, 会进行隐式转换, 把 <code>boolean</code> 转换成 <code>number</code></li><li>隐式转换的原理是使用 <code>MathObj.valueOf()</code> 方法</li><li>object 和 其他: 会将object 转换成基本类型(string || number)</li></ol><p><code>===</code> 既判断值也判断类型</p><h3 id="Q5-微任务或者宏任务"><a href="#Q5-微任务或者宏任务" class="headerlink" title="Q5: 微任务或者宏任务"></a>Q5: 微任务或者宏任务</h3><p>JavaScript是单线程的编程语言</p><blockquote><p>JS执行流程: 同步任务 -> 事件循环 [微任务 / 宏任务]</p><p>进入事件循环： 请求，定时器， 事件</p></blockquote><p><strong>面试题:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11111</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;,<span class="number">1000</span>*<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">22222</span>)</span><br><span class="line">问: 几秒输出几</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>11111</p><p>22222</p><p>3隔一秒</p><p>3隔一秒</p><p>3</p></blockquote><ol><li>宏任务</li></ol><blockquote><p>setTimeOut、setInterval</p></blockquote><ol start="2"><li>微任务</li></ol><blockquote><p>promise.then</p></blockquote><ol start="3"><li><p>执行宏任务的前提是执行完所有的微任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span> <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1 promise1&#x27;</span>);<span class="comment">//同步</span></span><br><span class="line"><span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微1&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微2&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);<span class="comment">//同步</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Q6-作用域"><a href="#Q6-作用域" class="headerlink" title="Q6: 作用域"></a>Q6: 作用域</h3><ol><li><p>除函数外, JS不存在快作用域</p></li><li><p>作用域链: 内部作用域可以访问外部变量, 外部不能访问内部的</p></li><li><p><strong>注意: 变量声明时没有 <code>var</code> 是全局定义</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a = b = <span class="number">10</span>;  </span><br><span class="line">&#125;)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>此处的 <code>var a = b = 10</code> 相当于 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  </span><br><span class="line"> b = <span class="number">0</span>  <span class="comment">// b 为全局变量</span></span><br></pre></td></tr></table></figure></li><li><p>变量提升机制</p><p>优先级:</p><p>提升机制提升时, 函数声明优先于变量声明. 但当变量已经定义后, 它的优先级大于普通函数声明</p><p>参数优先级大于变量提升</p><p>题1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b )</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">c</span>();<span class="comment">// undefinede 2 1</span></span><br></pre></td></tr></table></figure><p>题2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> name =<span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> name =<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>+name);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;222&#x27;</span>+name);</span><br><span class="line">&#125;)()<span class="comment">// 111b</span></span><br></pre></td></tr></table></figure></li><li><p><em><strong>提升机制提升时, 函数声明优先于变量声明. 但当变量已经定义后, 它的优先级大于普通函数声明</strong></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a )</span><br><span class="line">    <span class="keyword">var</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;&#125;</span><br><span class="line"><span class="title function_">fun</span>();<span class="comment">// function a()&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>();<span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Q7-JS对象"><a href="#Q7-JS对象" class="headerlink" title="Q7: JS对象"></a>Q7: JS对象</h3><ol><li><p>使用 <code>new</code> 操作符新建一个对象</p></li><li><p>对象的 <code>key</code> 都是字符串值</p></li><li><p>对象之间不相等, 除了引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>] === [<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>]<span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = obj2</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>面试题</p><p>题1: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 =</span><br><span class="line"><span class="attr">a</span>:<span class="string">&#x27;hellow&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.<span class="property">a</span>=<span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><strong>题2：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;；</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line"><span class="attr">key</span>:<span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line"><span class="attr">key</span>:<span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">a[b]=<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;456&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b])<span class="comment">// 456</span></span><br></pre></td></tr></table></figure></li><li><p>对象属性查找:</p><blockquote><p>函数对象的原型链: 对象本身 -> 构造函数 -> 对象原型 -> 构造函数原型 -> 对象上一层原型</p></blockquote></li></ol><h3 id="Q8-this指针综合"><a href="#Q8-this指针综合" class="headerlink" title="==Q8: this指针综合=="></a>==Q8: this指针综合==</h3><ol><li><p><code>this</code> 基本来说指向当前对象</p></li><li><p>题1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11111</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;aaaaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun);<span class="comment">//打印的是函数体</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fun</span>());<span class="comment">// 执行函数，打印返回值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">fun</span>())<span class="comment">// 打印function对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">xxx</span> = <span class="string">&#x27;xxx&#x27;</span><span class="comment">// this指向Function对象， 属性会在对象中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 普通函数的 this 指向 window 对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;aaaaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">fun</span>())<span class="comment">// fun &#123;xxx: &#x27;xxx&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>题2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> getName=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>();<span class="comment">//4 </span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>();<span class="comment">// 1</span></span><br><span class="line"><span class="title function_">getName</span>();<span class="comment">//1 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>();<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>题3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;ByteDance&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getA</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">let</span> funcA = a.<span class="property">getA</span>;</span><br><span class="line"><span class="title function_">funcA</span>();</span><br></pre></td></tr></table></figure></li><li><p>题4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">length</span>: <span class="number">5</span>,</span><br><span class="line"><span class="attr">test1</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">test2</span> = fn;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">test1</span>())<span class="comment">// 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>() === obj.<span class="title function_">test2</span>())<span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">test1</span>() == obj.<span class="title function_">test2</span>())<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Q9：-数组相关的问题"><a href="#Q9：-数组相关的问题" class="headerlink" title="Q9： 数组相关的问题"></a>Q9： 数组相关的问题</h3><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><blockquote><p>见 前端面经-JS（二） => Q3：JS内置对象及方法 => Array</p></blockquote><h4 id="判断数据是数组的方法"><a href="#判断数据是数组的方法" class="headerlink" title="判断数据是数组的方法"></a>判断数据是数组的方法</h4><ol><li><p><code>instanceof</code> 判断原型链上是否含有xxx</p><p><code> obj instanceof Object</code> : 在 <code>obj</code> 的原型链上是否含有 <code>Object</code></p></li><li><p><code>isArray</code> 判断是否是数组</p></li><li><p><code>arr.prototype.toString()</code> : 输出变量的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>() &gt; -<span class="number">1</span> </span><br></pre></td></tr></table></figure></li><li><p><code>arr.protoype.isPrototypeOf()</code></p><p><strong><code>isPrototypeOf()</code></strong> 方法用于检查一个对象是否存在于另一个对象的原型链中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(arr))</span><br></pre></td></tr></table></figure></li></ol><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><ol><li><p><strong>Set</strong> 数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]:</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr1))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="keyword">new</span> <span class="title class_">Set</span>(arr1)])</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>indexOf</code> </p><p><code>indexOf</code> 可以返回数组下标，如果不存在返回 -1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr </span>)&#123;</span><br><span class="line"><span class="keyword">var</span> brr = []</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(brr.<span class="title function_">indexof</span>(arr[i])==-<span class="number">1</span> )</span><br><span class="line">brr.<span class="title function_">push</span>(arr[i])   </span><br><span class="line"><span class="keyword">return</span> brr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>sort</code> </p><p>排序后利用前后元素不相等筛选</p></li></ol><h3 id="Q10-字符串相关问题"><a href="#Q10-字符串相关问题" class="headerlink" title="Q10: 字符串相关问题"></a>Q10: 字符串相关问题</h3><h4 id="给字符串新增方法实现功能"><a href="#给字符串新增方法实现功能" class="headerlink" title="给字符串新增方法实现功能"></a>给字符串新增方法实现功能</h4><p>给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前<br>缀的字符串，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;world&quot;</span>.<span class="title function_">addPrefix</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line"><span class="comment">// 控制台会输出：&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addPrefix</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;world&quot;</span>.<span class="title function_">addPrefix</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意此处不能使用 箭头函数 来声明方法</strong> </p><h4 id="统计字符数量"><a href="#统计字符数量" class="headerlink" title="统计字符数量"></a>统计字符数量</h4><ol><li><p>利用 <code>charAt</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;aaabbbbbccddddddddddx&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> char str.<span class="title function_">charAt</span>(i);</span><br><span class="line"><span class="keyword">if</span>(obj[char])&#123;</span><br><span class="line">obj [char]++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">obj [char]<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj )</span><br></pre></td></tr></table></figure></li><li><p>利用 <code>map</code> 数据结构</p><p><code>map.set()</code></p><p><code>map.get()</code></p></li></ol></script></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面经-Vue(三)</title>
      <link href="/2024/04/21/715/"/>
      <url>/2024/04/21/715/</url>
      
        <content type="html"><![CDATA[<h2 id="WebAPI（Vue）"><a href="#WebAPI（Vue）" class="headerlink" title="WebAPI（Vue）"></a>WebAPI（Vue）</h2><h3 id="set"><a href="#set" class="headerlink" title="$set"></a><code>$set</code></h3><p>设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法用于避开Vue不能检测属性被添加的限制。</p><p><strong>常见问题：</strong> <em>数据更新了页面还没更新是为什么？</em> </p><p>有可能是以下问题：</p><ol><li><p><em>Vue 无法检测实例被创建时不存在于 <code>data</code> 中的 property</em></p><p>由于 Vue 会在初始化实例时对 property 执行 <code>getter/setter</code> 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。</p></li><li><p><em>Vue 无法检测对象 property 的添加或移除</em></p><p>由于 JavaScript（ES5） 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 <code>getter/setter</code>，所以属性必须在 <code>data</code> 对象上才能让 Vue.js 转换它，才能让它是响应的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态添加 - vm.$set</span></span><br><span class="line">vm.$set(vm.<span class="property">obj</span>, propertyName, newValue)</span><br><span class="line"><span class="comment">// 动态添加多个 </span></span><br><span class="line"><span class="comment">// 代替 `Object.assign(this.obj, &#123; a: 1, b: 2 &#125;)`</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">obj</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">obj</span>, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p><em>Vue 不能检测利用数组索引直接修改一个数组项</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">items</span>[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(vm.<span class="property">items</span>, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vm.$set</span></span><br><span class="line">vm.$set(vm.<span class="property">items</span>, indexOfItem, newValue)</span><br></pre></td></tr></table></figure></li><li><p><em>在异步更新执行之前操作 DOM 数据不会变化</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example&quot;</span>&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">message</span> = <span class="string">&#x27;new message&#x27;</span> <span class="comment">// 更改数据</span></span><br><span class="line">vm.<span class="property">$el</span>.<span class="property">textContent</span> === <span class="string">&#x27;new message&#x27;</span> <span class="comment">// false</span></span><br><span class="line">vm.<span class="property">$el</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span> <span class="comment">// 页面没有变化</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.<span class="property">message</span> = <span class="string">&#x27;new message&#x27;</span> <span class="comment">// 更改数据</span></span><br><span class="line"><span class="comment">//使用 Vue.nextTick(callback) callback 将在 DOM 更新完成后被调用</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  vm.<span class="property">$el</span>.<span class="property">textContent</span> === <span class="string">&#x27;new message&#x27;</span> <span class="comment">// true</span></span><br><span class="line">  vm.<span class="property">$el</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span> <span class="comment">// 文字颜色变成红色</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><strong>!!!拓展：</strong> <em>Object.defineProperty() 可以监测数组的变化</em>  &#x3D;&#x3D;<strong>(Vue2响应式的原理)</strong>&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index</span>) &#123;</span><br><span class="line">    </span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(arr, index, &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发 setter&#x27;</span>)</span><br><span class="line">      item = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发 getter&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;123&#x27;</span>  <span class="comment">// 触发 setter</span></span><br><span class="line">arr[<span class="number">1</span>]          <span class="comment">// 触发 getter 返回值为 &quot;123&quot;</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">5</span>      <span class="comment">// 不会触发 setter 和 getter</span></span><br></pre></td></tr></table></figure><p><code>Vue3</code> 中, <code>Proxy</code> 替代 <code>defineProperty</code> 实现响应式</p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a><code>$nextTick</code></h3><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。所以就衍生出了这个<strong>获取更新后的DOM的Vue方法</strong>。所以<strong>放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js</strong>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="attr">testClick</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> that=<span class="variable language_">this</span>;</span><br><span class="line">    that.<span class="property">testMsg</span>=<span class="string">&quot;修改后的值&quot;</span>;</span><br><span class="line">    that.$nextTick(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">$refs</span>.<span class="property">aa</span>.<span class="property">innerText</span>);  <span class="comment">//输出：修改后的值</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="el"><a href="#el" class="headerlink" title="$el"></a>$el</h3><p><code>this</code>指向组件实例，<code>$el</code>用于获取<code>Vue</code>实例挂载的<code>DOM</code>元素，在<code>mounted</code>之后的生命周期中才有效，之前的钩子函数内无效。（跟生命周期各个阶段的行为有关，<code>mounted</code>之前没有DOM）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">    &lt;h1 @click=&quot;fn()&quot;&gt;</span><br><span class="line">      Lorem, ipsum</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    // this.$el只在mounted中才有效</span><br><span class="line">    console.log(&#x27;this:&#x27;, this) // 打印this指向组件实例。</span><br><span class="line">    console.log(&#x27;this.$el:&#x27;, this.$el) // 打印这个vue组件的dom对象</span><br><span class="line">    this.$el.style.color = &#x27;red&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn () &#123;</span><br><span class="line">      console.log(&#x27;test_this.$el:&#x27;, this.$el) // &lt;div id=&quot;root&quot;&gt;...&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="refs"><a href="#refs" class="headerlink" title="$refs()"></a>$refs()</h3><p> $refs 是一个对象，持有已注册过 ref 的所有的子组件。</p><p><strong>区别于 Vue3 <code>ref()方法</code>，ref()用于实现响应式数据</strong></p><h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><ol><li><code>$data</code> 获取当前日期</li><li><code>$children</code> 获取子组件, 返回一个数组</li><li><code>$root</code>  获取根组件</li><li><code>$parent</code> 获取父组件</li></ol><h3 id="data-定义数据"><a href="#data-定义数据" class="headerlink" title="data() 定义数据"></a>data() 定义数据</h3><ol><li><code>data</code> 是Vue的文件对象：</li></ol><ul><li><p>类型：Object | Function</p></li><li><p>限制：组件的定义只接受 function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;myComponent&quot;</span>,&#123;</span><br><span class="line"><span class="attr">props</span>: [],</span><br><span class="line"><span class="attr">data</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">newTodoText</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">visitCount</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">hideCompleteTodos</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">todos</span>: [],</span><br><span class="line"><span class="attr">error</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>Vue实例的数据对象，<strong>Vue</strong>将会递归将data的属性转换为<code>getter/setter</code>，从而让data的属性能够响应数据变化。</p><p>对象必须是纯粹的对象（含有零个或多个的key&#x2F;value对）：浏览器API创建的原生对象，原型上的属性会被忽略。大概来说，data应该只能是数据，不推荐观察拥有状态行为的对象。</p><p>一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vue</span> = &#123; </span><br><span class="line"><span class="attr">_newTodoText</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">newTodoText</span>()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_newTodoText</span>;</span><br><span class="line">&#125;.</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">newTodoText</span>(<span class="params">value</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_newTodoText</span> = vlaue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。<strong>Vue</strong>实例也代理了<strong>data</strong>对象上所有的属性，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code> </p><p>以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 <code>Vue</code> 实例代理，因为它们可能和<strong>Vue</strong>内置的属性、<strong>API</strong>方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p></li><li><p>当一个<strong>组件</strong>被定义，<code>data</code> 必须声明为 <em>返回</em> 一个初始数据对象的函数. 为什么组件（component）里定义的 <code>data</code> 必须是方法类型，原因是<strong>组件就是一个可复用的vue的实例。</strong>这也就意味着如果你的data是一个普通的对象，那么所有复用这个实例的组件都将引用同一份数据，这就造成了<strong>数据污染</strong><br>我们将 <code>data</code> 封装成一个函数，我们在实例化组件的时候只是调用了这个函数生成的数据副本，这就避免了数据污染。</p></li><li><p>为什么在大型项目中 <code>data</code> 需要使用return返回数据呢？</p><p>答：不使用 <code>return</code> 包裹的数据会在项目的全局可见，会造成变量污染；使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。</p></li></ol><h3 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h3><p>在 Vue 3 中，计算属性（Computed Properties）允许你声明一个依赖于其他响应式数据属性的属性，并且这个属性的值会根据其依赖的数据的变化而自动更新。计算属性是基于它们的依赖关系进行缓存的，只有在它的相关依赖发生改变时才会重新求值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>原始值：&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计算后的值：&#123;&#123; reversedMessage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;message = &#x27;Hello World!&#x27;&quot;</span>&gt;</span>修改原始值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello Vue3&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> reversedMessage = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> message.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      message,</span></span><br><span class="line"><span class="language-javascript">      reversedMessage</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Vue 3 中，计算属性不仅仅是一个简单的计算结果的缓存，它们还允许你定义一个 setter 函数，该函数会在你尝试修改计算属性的值时触发。这为你提供了一种方式来观察或拦截对计算属性的更改。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computedValue = <span class="title function_">computed</span>(&#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> baseValue.<span class="property">value</span> * <span class="number">2</span>; <span class="comment">// Getter</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        baseValue.<span class="property">value</span> = newValue / <span class="number">2</span>; <span class="comment">// Setter</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">incrementComputedValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 直接修改计算属性的值会触发 setter</span></span><br><span class="line">      computedValue.<span class="property">value</span> += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> <code>computed</code> 中的 <code>this</code> 指向 vm 实例</p><h3 id="computed-和-data-可以重名吗"><a href="#computed-和-data-可以重名吗" class="headerlink" title="computed 和 data 可以重名吗?"></a><code>computed</code> 和 <code>data</code> 可以重名吗?</h3><p>由于 <code>computed</code>, <code>data</code>, 和 <code>props</code> 都是挂载在Vue实例上的,所以不能重名.</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ol><li><p>基本用法</p><p><code>watch</code> 是vue内部提供的一个用于侦听功能的更通用的方法，其用来响应数据的变化，通过特定的数据变化驱动一些操作。vue官方文档解释当需要在数据变化时执行异步或开销较大的操作时，推荐使用该方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="attr">variable</span>:<span class="literal">null</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line"><span class="comment">// 此处监听variable变量，当期有变化时执行</span></span><br><span class="line"><span class="title function_">variable</span>(<span class="params">item1,item2</span>)&#123;</span><br><span class="line"><span class="comment">// item1为新值，item2为旧值</span></span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// variable:&#123;</span></span><br><span class="line"><span class="comment">//// 此处监听variable变量，当期有变化时执行</span></span><br><span class="line"><span class="comment">//handler(item1,item2)&#123;</span></span><br><span class="line"><span class="comment">//// item1为新值，item2为旧值</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>immediate</code> 用法</p><p>当未设置 <code>immediate</code> 或者 <code>immediate</code> 的值为 <code>false</code> 时，被侦听的变量在页面初次加载时第一次绑定值的时候，并不会执行监听操作；但是当设置了 <code>immediate</code> 的值为 <code>true</code> 时，则会立刻执行一次监听操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line"><span class="comment">// 此处监听variable变量，当期有变化时执行</span></span><br><span class="line"><span class="title function_">variable</span>(<span class="params">item1,item2</span>)&#123;</span><br><span class="line"><span class="comment">// item1为新值，item2为旧值</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">immediate</span>:<span class="literal">true</span> <span class="comment">// watch侦听操作内的函数会立刻被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>deep深度监听</p><p><em>侦听普通变量的变化</em>是使用以上方法，当侦听的某个变量值是对象时则不起作用，这时需要使用deep深度监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="attr">obj</span>:&#123;</span><br><span class="line"><span class="attr">a</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="attr">b</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="attr">c</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line"><span class="attr">obj</span>:&#123;</span><br><span class="line"><span class="comment">// 此处监听obj属性a值变量</span></span><br><span class="line"><span class="title function_">handler</span>(<span class="params">item1,item2</span>)&#123;</span><br><span class="line"><span class="comment">// item1为新值，item2为旧值</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">deep</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组（一维、多维）的变化不需要深度监听，对象数组中对象的属性变化则需要deep深度监听</p><p><em>对象属性变化</em></p><p>对象内某个属性产生变化，直接监听该对象是监测不到变化的，只能监听该对象的属性变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="attr">newObj</span>:&#123;</span><br><span class="line"><span class="attr">a</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line"><span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line"><span class="string">&#x27;newObj.a&#x27;</span>(val)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>数组对象中对象属性变化</em></p><p>数组对象中对象属性变化监测需要使用deep:true，多少层内产生变化都可以监测到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="attr">newArr</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">list</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">label</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">newArr</span>[<span class="number">0</span>].<span class="property">list</span>[<span class="number">0</span>].<span class="property">label</span> = <span class="string">&quot;2020年11月10日10:36:58&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line"><span class="attr">newArr</span>:&#123;</span><br><span class="line"><span class="title function_">handler</span>(<span class="params">val</span>)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">deep</span>:<span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/weixin_41993525/article/details/109492837">https://blog.csdn.net/weixin_41993525/article/details/109492837</a></p></li></ol><h3 id="method与computed"><a href="#method与computed" class="headerlink" title="method与computed"></a>method与computed</h3><ol><li>Computed</li></ol><p>​    Computed 是一种以声明式的方式处理数据的方式。可以通过在 Vue 实例中定义 <code>computed</code> 属性 <em>(Vue2)<em>或在组件中使用 <code>computed</code> 选项 <em>(Vue3)</em> 来创建</em>计算属性</em>。</p><p>计算属性是根据依赖的数据进行缓存的，只有当依赖的数据发生变化时，计算属性才会重新计算。这样可以避免不必要的重复计算，提高性能。</p><p>Computed 的使用场景包括：</p><ul><li>数据衍生：当需要根据已有数据计算出新的数据时，可以使用计算属性。例如，根据商品的价格和数量计算出总价。</li><li>数据过滤和转换：当需要对数据进行过滤、格式化或转换时，可以使用计算属性。例如，将日期格式化为特定的显示格式。</li></ul><p>需要注意的是，计算属性只会在依赖的数据发生变化时才重新计算，因此适用于那些相对稳定的数据计算场景。</p><ol start="2"><li><p>Methods</p><p>Methods 是一种以命令式的方式处理数据的方式。你可以在 Vue 实例中定义 methods 属性或在组件中使用 methods 选项来创建方法。 方法可以接受参数，并根据参数进行相应的操作。每次调用方法时，都会执行其中的代码并返回结果。</p></li></ol><p>Methods 的使用场景包括：</p><ul><li>事件处理：当需要处理用户交互事件时，可以使用方法。例如，点击按钮时执行特定的操作。</li><li>复杂逻辑：当需要执行复杂的业务逻辑，或者需要进行条件判断和循环操作时，可以使用方法。</li></ul><p>需要注意的是，每次调用方法时，都会执行其中的代码，不会进行缓存。因此，如果方法中包含复杂的计算逻辑或者涉及频繁调用的场景，可能会对性能产生影响。</p><ol start="3"><li><code>Computed</code> 和 <code>Methods</code> 的区别</li></ol><table><thead><tr><th></th><th>Computed</th><th>Methods</th></tr></thead><tbody><tr><td>缓存机制</td><td>具有缓存机制，只有在依赖数据变化时才重新计算</td><td>每次调用都会执行其中的代码</td></tr><tr><td>使用场景</td><td>适用于根据已有数据衍生新的数据和数据过滤&#x2F;转换场景，并具有缓存机制提高性能</td><td>适用于处理事件和复杂逻辑的场景</td></tr><tr><td>加载顺序</td><td>HTML DOM加载后马上执行, 混入Vue实例中</td><td>在调用后才执行, 不调用不执行</td></tr><tr><td>加载时</td><td>compted 当数据没有改变时是直接从缓存里取数据</td><td>methods每次都需要执行获得结果</td></tr></tbody></table><p><strong>注意:</strong> </p><p>**默认情况: **<code>computed</code> 在DOM加载后马上执行,  <code>watch</code> 在 <code>computed</code> 执后执行, 而<code>Methods</code> 默认不执行.  </p><p><strong>触发某一事件：</strong> 先 <code>computed</code> 后 <code>methods</code> 最后才是 <code>watch</code>, 原因是 <code>computed</code> 是基于缓存加载的.</p><hr><table><thead><tr><th>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_58013334/article/details/132381524">https://blog.csdn.net/m0_58013334/article/details/132381524</a></th></tr></thead></table><h2 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h2><p>12个常见指令，顺序如下：v-on、v-bind、v-model、v-for、v-show、v-if、v-else&#x2F;v-else-if、v-text、 v-html、v-cloak、v-once、v-pre</p><ol><li><p><code>v-on</code></p><p><em>用于绑定事件</em>, 语法糖 <code>@</code>, 参数为 @click(arg1, arg2 …, event)</p><p><em>绑定单个</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;ShowInfo&quot;</span>&gt;</span>鼠标单击事件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常用事件: </p><p>键盘事件: keyup(释放), keyDown(按下), keypress(除 shift, Fn, CapsLock外的连续触发)</p><p>表单事件：reset(重置), submit(提交)，input(用于实时查询), blur(失去焦点)</p><p><em>绑定多个事件:</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123;click:single,dblclick:double&#125;&quot;</span>&gt;</span>单击n+1,双击m-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-bind</code></p><p>单向数据绑定，它是为标签里的某个属性绑定值用的</p><p><code>v-bind:</code>可以简写为 “<code>:</code>“ :herf&#x3D;’xxx’</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">  单向数据绑定：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-model</p><p>双向数据绑定，v-model只能应用在表单类元素（如：input、select等）</p><p><code>v-model:value</code> 可以简写为 <code>v-model</code>，因为v-model默认收集的就是value值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">   双向数据绑定：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model:value</span>=<span class="string">&quot;aname&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 下边一行代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;h2 v-model:x=&quot;name&quot;&gt;你好啊&lt;/h2&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-for</p><p><em>数组遍历</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">&quot;(i,index) in arr&quot;</span>&gt;</span>每一项：&#123;&#123;i&#125;&#125;--索引值：&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>对象遍历</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">&quot;(i,index) in arr&quot;</span>&gt;</span>键：&#123;&#123;i&#125;&#125;--值：&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>迭代数字</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">&quot;(i,index) in 6&quot;</span>&gt;</span>每一项：&#123;&#123;i&#125;&#125;--索引：&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-show</p><p>条件渲染，<code>v-show</code>指令通过改变元素的 css 属性（display）来决定元素是显示还是隐藏。<code>v-show</code>等于false时,相当于设置了样式的display为none</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-show</span>=<span class="string">&quot;showTest&quot;</span>&gt;</span>v-show = true,故这个元素显示出来了<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-if, v-else&#x2F;v-else-if</p><p>条件渲染，与<code>v-show</code>类似，唯一不同的是，当<code>v-if = false</code>的时候，直接删掉DOM结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;ifTest&quot;</span>&gt;</span>v-if = true,故这个元素显示出来了<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-if</code> 和 <code>v-show</code> 的区别</p><table><thead><tr><th></th><th>v-if</th><th>v-show</th></tr></thead><tbody><tr><td>隐藏原理</td><td>删掉DOM节点结构达到隐藏元素的目的</td><td>通过设定 disploy: none; 设置节点不显示</td></tr><tr><td>性能</td><td>由于含有多次的添加、删除节点操作，性能较差</td><td>只加载一次结构，之后通过CSS设置隐藏，性能较好</td></tr></tbody></table></li><li><p>为什么要避免 <code>v-for</code> 和 <code>v-if</code> 的同时出现</p><p> 因为v-for的优先级比v-if 的优先级高，所以每次渲染时都会先循环再进行条件判断，而又因为v-if 会根据渲染条件为true 或false来决定渲染与否的，所以如果将v-if 和v-for用在一起会特别消耗性能</p><p><strong>解决方法:</strong></p><ol><li>将v-if 放在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for 循环</li><li>如果条件出现在循环内部，不得不放在一起，可通过计算属性computed提前过滤掉那些不需要显示的项</li></ol></li><li><p>v-text</p><p>用于将数据填充到标签中，作用于插值语法表达式类似，但是没有闪动问题 （如果数据中有HTML标签会将html标签一并输出 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">&quot;str&quot;</span>&gt;</span>公众号:<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>v-text会把解析到为文本<strong>完全替换掉</strong>标签里的内容</li><li>不能解析字符串，v-text会把所有的字符串都当成正常的文本解析，不会当成标签，即使你的data里的str数据中有标签结构</li></ol></li><li><p>v-html</p><p>v-html和v-text的区别：它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</p><p><strong>严重注意：v-html有安全性问题！！！</strong></p><ol><li><p>在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p></li><li><p>一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p></li></ol></li><li><p>v-cloak</p><p>防止闪烁,本质是一个<strong>特殊属性</strong>，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。使用css配合v-cloak可以解决<strong>网速慢</strong>时页面展示出的问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-cloak<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">   <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line"><span class="language-css">     <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">   &#125;</span></span><br><span class="line"><span class="language-css"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">name</span>:<span class="string">&quot;Dapan&quot;</span></span></span><br><span class="line"><span class="language-javascript">     &#125;,</span></span><br><span class="line"><span class="language-javascript">   &#125;);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-once</p><p>v-once所在节点在初次动态渲染后，就视为<strong>静态内容</strong>了。以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-once</span>&gt;</span>初始化时候的n是:&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>现在的n是:&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;n++&quot;</span>&gt;</span>点我n加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-pre</p><p>跳过Vue在有<code>v-pre</code>属性的所在节点的编译过程。可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会<strong>加快编译速度</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-pre</span>&gt;</span>没有使用指令语法和插值语法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">name</span>: <span class="string">&#x27;dapan&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><table><thead><tr><th>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/483838000">https://zhuanlan.zhihu.com/p/483838000</a></th></tr></thead></table><h2 id="Vue修饰符"><a href="#Vue修饰符" class="headerlink" title="Vue修饰符"></a>Vue修饰符</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Vue </tag>
            
            <tag> WebAPI </tag>
            
            <tag> Vue指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue常见问题(一)</title>
      <link href="/2024/04/17/22669/"/>
      <url>/2024/04/17/22669/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue数据绑定原理"><a href="#Vue数据绑定原理" class="headerlink" title="Vue数据绑定原理"></a>Vue数据绑定原理</h2><p><strong>Vue数据绑定采用 <code>数据劫持</code> 和 <code>订阅者-发布者</code> 结合的模式。</strong></p><ol><li><p>Vue2中，使用ES5中引入的 <code>defineProperty</code> 方法,它可以在一个对象上定义一个新属性，或者修改一个对象的现有属性,并返回这个对象。</p><p><em>语法：</em> <code>Object.defineProperty(obj, prop, descriptor)</code></p><p>Object.defineProperty还有一个重要的特性：<strong>它可以定义访问器属性</strong>。访问器属性不包含数据值，而是由一对 <code>getter</code> 和 <code>setter</code> 函数来获取或设置值。通过使用访问器属性，我们可以实现数据绑定、验证、计算等功能。这也是Vue2的数据响应的原理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个空对象</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.defineProperty给obj添加一个fullName属性，该属性由firstName和lastName组成，并且不能直接修改。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;fullName&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Cannot set fullName directly&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给obj添加firstName和lastName两个普通属性，并赋值。</span></span><br><span class="line">obj.<span class="property">firstName</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">obj.<span class="property">lastName</span> = <span class="string">&#x27;Cruise&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印obj.fullName</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">fullName</span>); <span class="comment">// Tom Cruise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改obj.fullName</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  obj.<span class="property">fullName</span> = <span class="string">&#x27;Jerry Seinfeld&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">message</span>); <span class="comment">// Cannot set fullName directly </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>Vue2</code> 中, 需要使用 **<code>observe</code>**将数据对象进行递归遍历, 给对象的属性以及子属性对象的属性加上 <code>setter</code> 和 <code>getter</code> 用于监听数据变化。</p><p>在这基础上，**<code>compile</code>** 解析模版指令，将数据渲染到页面上。初始化渲染时，给每个节点添加相应的更新函数进行绑定。</p><p><code>watcher</code> 是作为订阅者的角色, 用以沟通 <code>observe</code> 和 <code>compile</code>:</p><p>​当数据变化时 <code>dep.notify()</code> 发出通知, 订阅者 <code>watcher</code> 调用自身的 <code>update()</code> 方法, 触发 <code>compile</code> 的回调, 进行重新渲染。</p><p>​视图变化时，触发事件绑定的回调函数，调用数据对象的 <code>set</code> 方法修改数据。</p><p>从而实现数据的<strong>双向绑定</strong>。</p></li><li><p>Vue3中, 使用 <code>Proxy</code> 实现数据绑定。Proxy是ES6中引入的一个新对象，它可以创建一个代理对象（proxy object），该代理对象可以拦截并改变对目标对象（target object）的各种操作。使用Proxy，我们不仅可以对单个属性进行控制，还可以对整个对象进行控制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个目标对象targetObj，包含name和age两个普通属性。</span></span><br><span class="line"><span class="keyword">let</span> targetObj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一个代理对象proxyObj，并传入目标对象targetObj作为第一个参数。</span></span><br><span class="line"><span class="keyword">let</span> proxyObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObj, &#123;</span><br><span class="line">  <span class="comment">// 定义get拦截器函数，在读取代理对象任何属性时触发。</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果读取不存在的属性，则返回undefined。</span></span><br><span class="line">    <span class="keyword">if</span> (!(prop <span class="keyword">in</span> target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果读取name属性，则在后面加上&#x27;(proxy)&#x27;字样。</span></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop] + <span class="string">&#x27;(proxy)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况下正常返回目标对象相</span></span><br><span class="line"><span class="keyword">return</span> target[prop];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义set拦截器函数，在修改代理对象任何属性时触发。</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果修改name属性，则抛出错误，不允许修改。</span></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Cannot set name property&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果修改age属性，则检查值是否为合法的数字，如果不是，则抛出错误，如果是，则更新目标对象相应属性的值。</span></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span> || <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Age must be a valid number&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      target[prop] = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况下正常更新目标对象相应属性的值。</span></span><br><span class="line">    target[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印proxyObj.name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyObj.<span class="property">name</span>); <span class="comment">// Tom(proxy)</span></span><br><span class="line"><span class="comment">// 打印proxyObj.age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyObj.<span class="property">age</span>); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改proxyObj.name</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  proxyObj.<span class="property">name</span> = <span class="string">&#x27;Jerry&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">message</span>); <span class="comment">// Cannot set name property </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改proxyObj.age</span></span><br><span class="line">proxyObj.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line"><span class="comment">// 打印proxyObj.age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyObj.<span class="property">age</span>); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 实际问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（一）</title>
      <link href="/2024/04/16/40594/"/>
      <url>/2024/04/16/40594/</url>
      
        <content type="html"><![CDATA[<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><ul><li>思路：<ol><li>从数组的第一个元素开始。</li><li>逐个检查每个元素，直到找到目标元素或遍历完整个数组。</li></ol></li><li>注意点：简单但效率低，适用于小数组或数据分布不均匀的情况。</li></ul><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><ul><li><p>思路：</p><ol><li><p>在有序数组中，找到中间的元素。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);<span class="string">` </span></span><br></pre></td></tr></table></figure></li><li><p>比较中间元素与目标元素。</p></li><li><p>如果中间元素等于目标元素，则查找成功。</p></li><li><p>如果中间元素小于目标元素，则在右半部分递归查找。</p></li><li><p>如果中间元素大于目标元素，则在左半部分递归查找。</p></li></ol></li><li><p>注意点：数组必须是有序的，适用于大数据量且有序的情况。</p></li></ul><h4 id="哈希查找"><a href="#哈希查找" class="headerlink" title="* 哈希查找"></a>* 哈希查找</h4><ul><li><p>思路：</p><ol><li>使用哈希函数将键映射到哈希表的索引。</li><li>直接访问该索引位置查找元素。</li></ol></li><li><p>注意点：哈希函数的设计和冲突解决策略对性能至关重要，适用于快速查找且内存空间允许的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义哈希表类HashTable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="comment">// 构造函数，初始化哈希表</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">size = <span class="number">42</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个指定大小的数组，用于存储哈希桶</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">buckets</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(size);</span><br><span class="line">    <span class="comment">// 保存哈希表的大小</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 哈希函数，将键转换成哈希桶索引</span></span><br><span class="line">  <span class="title function_">hash</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用键的字符串表示的长度进行模运算，得到索引值</span></span><br><span class="line">    <span class="keyword">return</span> key.<span class="title function_">toString</span>().<span class="property">length</span> % <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置键值对</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算键的哈希值</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="comment">// 如果当前索引的桶为空，初始化为一个空数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">buckets</span>[index]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">buckets</span>[index] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将键值对添加到对应的桶中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">buckets</span>[index].<span class="title function_">push</span>([key, value]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取键对应的值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算键的哈希值</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="comment">// 如果对应桶不存在，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">buckets</span>[index]) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历桶中的元素，寻找匹配的键</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">buckets</span>[index]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k === key) &#123;</span><br><span class="line">        <span class="comment">// 如果找到匹配的键，返回对应的值</span></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈希表实例</span></span><br><span class="line"><span class="keyword">let</span> hashTable = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line"><span class="comment">// 在哈希表中设置键为&#x27;name&#x27;的值为&#x27;John&#x27;</span></span><br><span class="line">hashTable.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="comment">// 在哈希表中设置键为&#x27;age&#x27;的值为25</span></span><br><span class="line">hashTable.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 打印出键&#x27;name&#x27;对应的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashTable.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// John</span></span><br><span class="line"><span class="comment">// 打印出键&#x27;age&#x27;对应的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashTable.<span class="title function_">get</span>(<span class="string">&#x27;age&#x27;</span>)); <span class="comment">// 25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉搜索树（BST）查找"><a href="#二叉搜索树（BST）查找" class="headerlink" title="二叉搜索树（BST）查找"></a>二叉搜索树（BST）查找</h4><ul><li>思路：<ol><li>从树的根节点开始。</li><li>比较当前节点的值与目标值。</li><li>如果当前节点的值等于目标值，查找成功。</li><li>如果目标值小于当前节点的值，则在左子树中递归查找。</li><li>如果目标值大于当前节点的值，则在右子树中递归查找。</li></ol></li><li>注意点：树的结构对查找效率有重要影响，平衡树（如AVL树、红黑树）可以提供更稳定的性能。</li></ul><h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><ul><li>思路：与二叉搜索树查找类似，但在红黑树中，节点还包含了颜色信息，用于维护树的平衡。</li><li>注意点：红黑树的自平衡特性保证了查找、插入和删除的最坏情况时间复杂度为O(log n)。</li></ul><h4 id="平衡查找树（AVL树）查找"><a href="#平衡查找树（AVL树）查找" class="headerlink" title="平衡查找树（AVL树）查找"></a>平衡查找树（AVL树）查找</h4><ul><li><p>思路：与二叉搜索树查找类似，但在AVL树中，每个节点的左右子树的高度差不超过1。</p></li><li><p>注意点：AVL树的高度平衡保证了查找效率的稳定。</p></li><li></li></ul><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li>思路：<ol><li>从数组的第一个元素开始，比较相邻元素。</li><li>如果顺序错误，则交换它们的位置。</li><li>每轮遍历后，最大的元素会被移动到数组的末尾。</li><li>重复上述步骤，直到整个数组有序。</li></ol></li><li>注意点：简单但效率低，适用于小数组。</li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li>思路：<ol><li>选择一个基准元素。</li><li>将数组分为小于和大于基准的两部分。</li><li>递归地对这两部分进行快速排序。</li></ol></li><li>注意点：基准元素的选择和数组的分割方式对性能有重要影响，适用于大数据量。</li></ul><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul><li><p>思路：</p><ol><li>从数组的第二个元素开始，将其与前面的元素比较。</li><li>如果前面的元素大于当前元素，则将前面的元素向后移动一位。</li><li>重复上述步骤，直到当前元素找到合适的位置。</li><li>逐步将未排序的元素插入到已排序的部分。</li></ol></li><li><p>注意点：适用于小数组或基本有序的大数组，效率高于选择排序和冒泡排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将arr[i]与已排序的arr[0...i-1]中的元素比较，找到插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      j = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul><li>思路：<ol><li>将数组分成若干个小数组。</li><li>逐个合并这些小数组，使其有序。</li><li>最终得到一个有序的大数组。</li></ol></li><li>注意点：需要额外的内存空间来存储临时数组，适用于大数据量且内存充足的情况。<br>在实现这些算法时，需要注意以下几点：</li><li>算法的时间复杂度和空间复杂度。</li><li>算法稳定性，即相同元素的相对顺序在排序后是否保持不变。</li><li>边界条件处理，如空数组、重复元素等。</li><li>优化措施，如减少不必要的交换和比较，选择合适的算法参数等。</li></ul><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li><p>思路：</p><ol><li>选择一个增量序列。</li><li>根据增量将数组分成多个子序列。</li><li>对每个子序列使用插入排序。</li><li>缩小增量，重复上述步骤。</li></ol></li><li><p>注意点：增量序列的选择对性能有重要影响，适用于中等大小的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid);</span><br><span class="line">  <span class="keyword">const</span> right = arr.<span class="title function_">slice</span>(mid);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rightIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (leftIndex &lt; left.<span class="property">length</span> &amp;&amp; rightIndex &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(left[leftIndex++]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(right[rightIndex++]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">concat</span>(left.<span class="title function_">slice</span>(leftIndex)).<span class="title function_">concat</span>(right.<span class="title function_">slice</span>(rightIndex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li>思路：<ol><li>构建一个最大堆。</li><li>交换堆顶元素（最大值）与堆底元素。</li><li>重新调整堆，使其满足最大堆性质。</li><li>重复步骤2和3，直到堆中只剩下一个元素。</li></ol></li><li>注意点：堆的维护和调整对性能有重要影响，适用于大数据量。</li></ul><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul><li>思路：<ol><li>找出数组中的最大值和最小值。</li><li>创建一个计数数组，大小为最大值与最小值之差加1。</li><li>计算每个元素出现的次数。</li><li>根据计数数组重建原数组。</li></ol></li><li>注意点：适用于非负整数排序，且最大值和最小值之间的范围不大。</li></ul><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul><li>思路：<ol><li>将数组划分成多个桶。</li><li>每个桶内部进行排序（可以使用其他排序算法）。</li><li>合并所有桶的元素，得到排序后的数组。</li></ol></li><li>注意点：适用于数据分布均匀且可以划分为多个桶的情况。</li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li>思路：<ol><li>按照元素的每个位（个位、十位、百位等）进行排序。</li><li>从最低位开始，使用计数排序或其他稳定排序算法。</li><li>逐步排序到最高位，得到最终排序结果。</li></ol></li><li>注意点：适用于非负整数排序，且数字位数不多的情况。<br>在实现这些算法时，需要注意以下几点：</li><li>算法的时间复杂度和空间复杂度。</li><li>算法稳定性，即相同元素的相对顺序在排序后是否保持不变。</li><li>边界条件处理，如空数组、重复元素等。</li><li>优化措施，如减少不必要的交换和比较，选择合适的算法参数等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法逻辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面经-Vue(一)</title>
      <link href="/2024/04/16/30015/"/>
      <url>/2024/04/16/30015/</url>
      
        <content type="html"><![CDATA[<h2 id="关于生命周期"><a href="#关于生命周期" class="headerlink" title="关于生命周期"></a><strong>关于生命周期</strong></h2><h3 id="生命周期有哪些-在那里发送请求？"><a href="#生命周期有哪些-在那里发送请求？" class="headerlink" title="生命周期有哪些,在那里发送请求？"></a>生命周期有哪些,在那里发送请求？</h3><p><strong>生命周期：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate// 初始化之后调用</span><br><span class="line">created  // 完成data observe 和 watch, 此时 $el 不可见</span><br><span class="line">beforeMount// 首次调用 render函数</span><br><span class="line">mounted  // 将虚拟DOM挂载到 DOM上</span><br><span class="line">beforeUpdate  // 数据更新，$el未更新,可以访问现有DOM, 只在客户端渲染, 服务端只会初次渲染</span><br><span class="line">updated  // $el更新</span><br><span class="line">activated dectivated // keep-alive中调用</span><br><span class="line">beforeDestroy// 销毁之前，$el 仍然可用</span><br><span class="line">destroyed  // 解绑实例，子实例和监视器也被销毁</span><br></pre></td></tr></table></figure><p><strong>发送请求：</strong><br>一般来说，在 <code>created</code> 和 <code>mounted </code> 都是可以的，但是，如果父子组件都会发送请求，这样就需要考虑父子生命周期的加载顺序。</p><h3 id="一旦进入组件，会执行哪些生命周期？"><a href="#一旦进入组件，会执行哪些生命周期？" class="headerlink" title="一旦进入组件，会执行哪些生命周期？"></a>一旦进入组件，会执行哪些生命周期？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beforeCreatecreated</span><br><span class="line">beforeMountmounted</span><br></pre></td></tr></table></figure><h3 id="※-父组件引入子组件，执行生命周期的顺序是？"><a href="#※-父组件引入子组件，执行生命周期的顺序是？" class="headerlink" title="※ 父组件引入子组件，执行生命周期的顺序是？"></a>※ 父组件引入子组件，执行生命周期的顺序是？</h3><p>父：<code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code></p><p>子：<code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code> &#x3D;&gt; <code>mounted</code> </p><p>……</p><p>父：<code>mounted</code></p><h3 id="※-为什么发送请求不在beforeCreate-它与created有什么不同？"><a href="#※-为什么发送请求不在beforeCreate-它与created有什么不同？" class="headerlink" title="※ 为什么发送请求不在beforeCreate,它与created有什么不同？"></a>※ 为什么发送请求不在<code>beforeCreate</code>,它与<code>created</code>有什么不同？</h3><p>在 <code>beforeCreate</code> 阶段，系统&#x2F; <code>beforeCreate</code> 无法调用 methods 中的方法，如果请求封装在方法中，那就无法发送<br>如果直接异步获取，在哪个生命周期都可以（ <code>beforeCreate</code> &#x2F; <code>created</code> &#x2F; <code>mounted</code>)</p><h3 id="在created中如何获取DOM信息？"><a href="#在created中如何获取DOM信息？" class="headerlink" title="在created中如何获取DOM信息？"></a>在<code>created</code>中如何获取DOM信息？</h3><p>在 <code>created</code> 中使用 <code>this.$el</code> 异步的请求就可以获取到DOM信息。<br>    原理是异步请求在同步请求完成之后进行，这样即可保存当前的参数信息，在生命周期执行完毕后输出。比如 <code>setTimeOut(callback, time)</code>, <code>Promise()</code>, <code>aysnc + awiat</code> 和<code>this.nextTick(callback)</code>(Vue内置的异步方法)。</p><h3 id="keep-alive有什么作用，使用keep-alive后会执行什么生命周期？"><a href="#keep-alive有什么作用，使用keep-alive后会执行什么生命周期？" class="headerlink" title="keep-alive有什么作用，使用keep-alive后会执行什么生命周期？"></a><code>keep-alive</code>有什么作用，使用<code>keep-alive</code>后会执行什么生命周期？</h3><ol><li><code>keep-alive</code> 用于缓存组件的信息。<br> 如果将组件置入<code>keep-alive</code>中，系统会缓存组件信息</li><li>使用时会多出两个生命周期：<br> <code>activated</code><code>deactivated</code></li><li>加入后，第一次的执行顺序为，<code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code> &#x3D;&gt; <code>mounted</code> &#x3D;&gt; <code>activated</code></li></ol><h3 id="第二次或第N次进入组件，生命周期的执行顺序："><a href="#第二次或第N次进入组件，生命周期的执行顺序：" class="headerlink" title="第二次或第N次进入组件，生命周期的执行顺序："></a>第二次或第N次进入组件，生命周期的执行顺序：</h3><ol><li>使用<code>keep-alive</code>组件后，第一次的执行顺序为: <code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code> &#x3D;&gt; <code>mounted</code> &#x3D;&gt; <code>activated</code>。<br> 而第二次只执行 <code>deactived</code>。</li><li>没有使用时，会执行 <code>beforeCreate</code> &#x3D;&gt; <code>created</code> &#x3D;&gt; <code>beforeMount</code> &#x3D;&gt; <code>mounted</code>。</li></ol><h3 id="在什么情况下用过哪些生命周期，场景有？"><a href="#在什么情况下用过哪些生命周期，场景有？" class="headerlink" title="在什么情况下用过哪些生命周期，场景有？"></a>在什么情况下用过哪些生命周期，场景有？</h3><ul><li>·发送请求时</li><li>进入详情页（关注内容变化）</li><li>关闭页面（切换路由）&#x3D;&gt; 参数收集</li></ul><h2 id="关于组件"><a href="#关于组件" class="headerlink" title="关于组件"></a>关于组件</h2><h3 id="组件通信的分类以及实现方法："><a href="#组件通信的分类以及实现方法：" class="headerlink" title="组件通信的分类以及实现方法："></a>组件通信的分类以及实现方法：</h3><p><em>父传子</em></p><ol><li>父组件绑定数据到子组件，子组件使用<code>props</code>引入数据：</li><li>直接使用<code>this.$parent.xxx</code></li><li>使用<code>provide、inject</code>依赖注入</li></ol><p><em>子传父</em></p><ol><li><p>子组件中：<code>vm.$emit( event, arg );</code> 触发当前实例上的事件, arg是传递给父组件的参数。</p><p>父组件中：<code>vm.$on( event, fn );</code> 监听event事件后运行 fn。</p><p><code>vm.$off(&quot;showCityName&quot;);</code> 移除自定义事件监听器。</p><ul><li>如果没有提供参数，则移除所有的事件监听器；</li><li>如果只提供了事件，则移除该事件所有的监听器；</li><li>如果同时提供了事件与回调，则只移除这个回调的监听器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    城市：&#123;&#123; city &#125;&#125;</span><br><span class="line">    &lt;button type=&quot;button&quot; @click=&quot;myfun(&#x27;大连&#x27;, &#x27;武汉&#x27;)&quot;&gt;子组件按钮点击&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;city&quot;],</span><br><span class="line">  mounted() &#123;</span><br><span class="line">      this.$on(&#x27;showCityName&#x27;,r=&gt;&#123;</span><br><span class="line">          console.log(r);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myfun(x) &#123;</span><br><span class="line">      this.$emit(&quot;showCityName&quot;, x);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  destoryed() &#123;</span><br><span class="line">    this.$off(&quot;showCityName&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>this.children[0].xxx</code></p></li><li><p><code>this.refs()</code></p></li></ol><p><em>兄弟组件之间传递消息</em></p><ol><li><p>使用 <code>eventBus</code></p><p>新建一个 <code>bus.js</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vue</span>();</span><br></pre></td></tr></table></figure><p>然后在你需要触发的 组件中引入 <code>import bus from ‘文件路径’</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bus.$emit(<span class="string">&#x27;触发名称&#x27;</span>, 传输的数据 )      <span class="comment">// 执行</span></span><br></pre></td></tr></table></figure><p>最后在你需要的通信的另一个组件中 mounted<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>钩子中执行如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bus.$on(<span class="string">&#x27;触发名称&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写你需要的方法</span></span><br><span class="line">    &#125;)</span><br><span class="line">mounted () &#123;</span><br><span class="line">bus.$on(‘testA’, <span class="variable language_">this</span>.<span class="property">testA</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>由父组件中转</p></li></ol><p>   A: <code>this.$emit(&#39;handleMessage&#39;,message)</code></p><p>   B: <code>this.$parent.$on(&#39;messageSent&#39;, this.handleMessage);</code></p><h3 id="组件通信相关问题"><a href="#组件通信相关问题" class="headerlink" title="组件通信相关问题"></a>组件通信相关问题</h3><ol><li><p>如何找父组件：<code>this.$parent</code></p></li><li><p>子组件如何直接修改父组件的值？        <code>this.$parent.xxx = xxx</code></p></li><li><p>父组件如何直接修改子组件的值？       <code>this.$children[0].xxx = xxx</code></p></li><li><p>如何找根组件:        <code>this.$root</code></p></li></ol><h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><ul><li><em>具名插槽</em></li></ul><p><code>&lt;BaseLayout&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>header.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template #header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #default&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br></pre></td></tr></table></figure><ul><li><em>匿名插槽</em></li></ul><p><code>&lt;FancyButton&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyButton&gt;</span><br><span class="line">  Click me! &lt;!-- 插槽内容 --&gt;</span><br><span class="line">&lt;/FancyButton&gt;</span><br></pre></td></tr></table></figure><p><code>FancyButton.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;fancy-btn&quot;&gt;</span><br><span class="line">  &lt;slot&gt;</span><br><span class="line">      Submit </span><br><span class="line">    &lt;/slot&gt; &lt;!-- 插槽出口, submit为默认内容 --&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><ul><li><em>定义域插槽</em></li></ul><p><code>&lt;FancyButton&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyButton&gt;</span><br><span class="line">  &lt;template #footer = &#123;arr&#125; &gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/FancyButton&gt;</span><br></pre></td></tr></table></figure><p><code>FancyButton.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;fancy-btn&quot;&gt;</span><br><span class="line">  &lt;slot name=&#x27;footer&#x27; :arr = arr&gt;</span><br><span class="line">      Submit </span><br><span class="line">    &lt;/slot&gt; &lt;!-- 插槽出口, submit为默认内容 --&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="provide、inject依赖注入"><a href="#provide、inject依赖注入" class="headerlink" title="provide、inject依赖注入"></a>provide、inject依赖注入</h3><p>父代组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, provide &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;message&#x27;</span>, count)</span><br></pre></td></tr></table></figure><p>后代组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">inject</span>(<span class="string">&#x27;message&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h3><h3 id="组件中的-name-属性"><a href="#组件中的-name-属性" class="headerlink" title="组件中的 name 属性"></a>组件中的 name 属性</h3><ol><li><p>注册组件名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;ComNameHello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>keep-alive</code> 时，搭配组件 <code>name</code> 进行<strong>缓存过滤</strong>, <code>name</code> 可以用作 <code>include</code> 和 <code>exclude</code> 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Table.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Table&#x27;</span></span><br><span class="line">&#125;，</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getData</span>();</span><br><span class="line">&#125;，</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">   <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span><br><span class="line">          axios.<span class="title function_">get</span>(<span class="string">&#x27;/xx/table.json&#x27;</span>,&#123;</span><br><span class="line">              <span class="attr">params</span>:&#123;</span><br><span class="line">                <span class="attr">id</span>:<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">id</span>  </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            .......</span><br><span class="line">          &#125;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">&lt;div id=&quot;app&quot;&gt; </span><br><span class="line">    &lt;keep-alive exclude=&quot;Table&quot;&gt;</span><br><span class="line">      &lt;router-view/&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在 <code>App.vue</code> 中使用 <code>keep-alive</code> 组件会缓存不活动的组件实例，而不是销毁它们。这样会导致我们滴二次进入页面时不会刷新页面，有两种方式可以解决这样的问题：</p><ol><li><p>在 <code>keep-alive</code> 中加入 <code>exclude</code> 属性，<code>exclude=&quot;Table&quot;</code> 这样就不会对 Table 组件进行缓存，第二次进入该页面时就会得到最新数据。</p></li><li><p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。这里把 <code>this.getData()</code> 放到 <code>activated</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">activated</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//第二种解决方案</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getData</span>();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>vue-devtools</code> 调试工具中，显示的组见名称由组件<code>name属性</code>决定</p></li><li><p>组件在当前自身组件中,递归调用自身组件</p><p>其实，除了name选项是必须的之外，还有一点也是在实现递归组件要注意的，就是要防止无限递归，造成调用栈溢出，在不满足条件时跳出递归。</p><p><code>父组件.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;tree :model=&quot;treeData&quot;&gt;&lt;/tree&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import tree from &#x27;@/components/tree&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        treeData: &#123;</span><br><span class="line">          title: &#x27;1&#x27;,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;title: &#x27;1-1&#x27;&#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;1-2&#x27;,</span><br><span class="line">              children: [</span><br><span class="line">                &#123;title: &#x27;1-2-1&#x27;&#125;,</span><br><span class="line">                &#123;title: &#x27;1-2-2&#x27;&#125;,</span><br><span class="line">                &#123;title: &#x27;1-2-3&#x27;&#125;,</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#x27;1-3&#x27;,</span><br><span class="line">              children: [</span><br><span class="line">                &#123;</span><br><span class="line">                  title: &#x27;1-3-1&#x27;,</span><br><span class="line">                  children: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      title: &#x27;1-3-1-1&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      title: &#x27;1-3-1-2&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;title: &#x27;1-3-2&#x27;&#125;,</span><br><span class="line">                &#123;title: &#x27;1-3-3&#x27;&#125;,</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><code>tree.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for=&quot;(item, index) in model&quot; :key=&quot;index&quot;&gt; </span><br><span class="line">        &#123;&#123; item.title &#125;&#125;</span><br><span class="line">      &lt;div v-if=&quot;item.children &amp;&amp; item.children.length&quot;&gt;</span><br><span class="line">        &lt;tree :model=&quot;item.children&quot;&gt;&lt;/tree&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 这里要写name:tree才可以递归</span><br><span class="line">  name: &quot;tree&quot;,</span><br><span class="line">  props: &#123; model: Array &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> web前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面经-Vue(二)</title>
      <link href="/2024/04/16/37481/"/>
      <url>/2024/04/16/37481/</url>
      
        <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="Vuex的属性"><a href="#Vuex的属性" class="headerlink" title="Vuex的属性"></a><strong>Vuex的属性</strong></h3><p><code>state</code> &#x3D;&gt; 全局共享数据</p><p><code>getters</code> &#x3D;&gt; 二次计算的数据</p><p><code>mutations</code> &#x3D;&gt; 同步方法</p><p><code>actions</code> &#x3D;&gt; 异步方法 &#x2F; 提交数据</p><p><code>modules</code> &#x3D;&gt; 模块划分<br>对比MVC的模型来看，<code>state</code>看成一个数据库，只是它是响应式的，刷新之后页面数据就会改变；actions看成controller层，做数据的业务逻辑；mutations看成model层，做数据的增删改查操作。</p><h3 id="state的使用"><a href="#state的使用" class="headerlink" title="state的使用"></a><strong><code>state</code>的使用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.state.xxx</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// mapState: 把 state 属性映射到 computed 身上</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">   <span class="title class_">Vuex</span>.<span class="title function_">mapState</span>(&#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="function"><span class="params">state</span>=&gt;</span>state.<span class="property">inputVal</span>,</span><br><span class="line">      <span class="attr">n</span>: <span class="function"><span class="params">state</span>=&gt;</span>state.<span class="property">n</span></span><br><span class="line">  &#125;)   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写形式：</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">...<span class="title function_">mapState</span>([<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;n&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>this.$store.state.xxx</code>可以修改数据，<code>mapState</code>不能修改数据。</p><h3 id="修改getter的值"><a href="#修改getter的值" class="headerlink" title="修改getter的值**"></a>修改<code>getter</code>的值**</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.<span class="property">xxx</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    ...<span class="title class_">Vuex</span>.<span class="title function_">mapGetters</span>(&#123;</span><br><span class="line">        <span class="title class_">NumN</span>:<span class="string">&quot;NumN&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;  </span><br><span class="line">...<span class="title function_">mapGetters</span>([<span class="string">&#x27;NumN&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getters</code>类似于组件里面<code>computed</code>，同时也<strong>监听属性的变化</strong>，当<code>state</code>中的属性发生改变的时候就会触发<code>getters</code>里面的方法。<code>getters</code>里面的每一个方法中都会有一个参数 <code>state</code>。</p><h3 id="mutation-和-action-的区别"><a href="#mutation-和-action-的区别" class="headerlink" title="mutation 和 action 的区别"></a><strong><code>mutation</code> 和 <code>action</code> 的区别</strong></h3><p><code>mutations</code>里面的函数主要用来修改<code>state</code>中的数据。<code>mutations</code>里面的所有方法都会有2个参数，一个是<code>store</code>中的<code>state</code>，另外一个是需要传递的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapMutations 把 mutations 里面的方法映射到 methods 中</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title class_">Vuex</span>.<span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">        <span class="attr">handleAdd</span>:<span class="string">&quot;handlMutationseAdd&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;  </span><br><span class="line">...<span class="title function_">mapMutations</span>([<span class="string">&#x27;handlMutationseAdd&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>actions</code>里面的函数主要用来处理<strong>异步操作</strong>以及一些业务逻辑,每一个函数里面都有一个形参，这个形参是一个对象，里面有一个<code>commit</code>方法，这个方法用来**触发<code>mutations</code>**里面的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapMutations 把 actions 里面的方法映射到 methods 中</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title class_">Vuex</span>.<span class="title function_">mapActionss</span>(&#123;</span><br><span class="line">        <span class="attr">handleAdd</span>:<span class="string">&quot;handlMutationseAdd&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActionss&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;  </span><br><span class="line">...<span class="title function_">mapActionss</span>([<span class="string">&#x27;handlMutationseAdd&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="modules的使用"><a href="#modules的使用" class="headerlink" title="modules的使用"></a><strong>modules的使用</strong></h3><p>modules是把公共的状态按照模块进行划分。每个模块都相当于一个小型的<code>Vuex</code>，即每个模块里面都会有<code>state</code> <code>getters</code> <code>actions</code> <code>mutations</code>。</p><p>多人协作开发的时候，可能子模块和主模块中的函数名字会相同，这样在调用函数的时候，相同名字的函数都会被调用，就会发生问题。为了解决这个问题，导出模块的时候要加 <code>namespace:true</code> ，主要的作用是将每个模块都有独立命名空间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块化后，<code>store</code>实例的<code>state</code>属性访问方式为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">todo</span>.<span class="property">inputVal</span></span><br></pre></td></tr></table></figure><h3 id="Vuex持久化储存"><a href="#Vuex持久化储存" class="headerlink" title="Vuex持久化储存"></a><strong>Vuex持久化储存</strong></h3><p><code>Vuex</code>本身不具有持久化存储的能力，vuex是单向数据流，存在vuex中的变量都是响应式数据。组件中一般会通过computed来使用store中的状态、且有缓存，但是当我们去刷新浏览器的时候，store中的状态都会被清空、重新初始化为最初的状态。要实现持久化存储，就是将其状态保存到<code>localStorage</code>或者<code>sessionStorage</code>中，实现方法有两种：</p><ol><li><p>使用插件：<code>vuex-persistedstate</code></p><p>安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex-persistedstate</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;./modules/test&#x27;</span></span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&#x27;./modules/user&#x27;</span></span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">&quot;vuex-persistedstate&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    test,</span><br><span class="line">    user</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* vuex数据持久化配置 */</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">createPersistedState</span>(&#123;</span><br><span class="line">      <span class="comment">// 存储方式：localStorage、sessionStorage、cookies</span></span><br><span class="line">      <span class="attr">storage</span>: <span class="variable language_">window</span>.<span class="property">sessionStorage</span>,</span><br><span class="line">      <span class="comment">// 存储的 key 的key值</span></span><br><span class="line">      <span class="attr">key</span>: <span class="string">&quot;store&quot;</span>,</span><br><span class="line">      <span class="title function_">reducer</span>(<span class="params">state</span>) &#123; <span class="comment">//render错误修改</span></span><br><span class="line">      <span class="comment">// 要存储的数据：本项目采用es6扩展运算符的方式存储了state中所有的数据</span></span><br><span class="line">        <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>如果只需要存储 <code>state</code> 中一部分数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="title function_">createPersistedState</span>(&#123;</span><br><span class="line">    <span class="attr">storage</span>: <span class="variable language_">window</span>.<span class="property">sessionStorage</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;store&quot;</span>,</span><br><span class="line">    <span class="comment">// 只持久化存储user模块的状态</span></span><br><span class="line">    <span class="attr">paths</span>: [<span class="string">&#x27;user&#x27;</span>]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li><li><p>自己实现：</p><p><code>utils/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储方式：localStorage、sessionStorage、cookies</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SessionUtils</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">getItem</span>(key))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">removeItem</span>(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在vuex中的使用：<code>store/index.js</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">SessionUtils</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/index.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="title class_">SessionUtils</span>.<span class="title function_">get</span>(<span class="string">&#x27;count&#x27;</span>) || <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">UPDATE_COUNT</span>(<span class="params">state, count</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">      <span class="title class_">SessionUtils</span>.<span class="title function_">set</span>(<span class="string">&#x27;count&#x27;</span>, state.<span class="property">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="路由的模式和区别"><a href="#路由的模式和区别" class="headerlink" title="路由的模式和区别"></a>路由的模式和区别</h3><table><thead><tr><th align="center"></th><th align="center">history</th><th align="center">hash</th></tr></thead><tbody><tr><td align="center">表象</td><td align="center"><a href="https://zhuanlan.zhihu.com/p/24814675">https://zhuanlan.zhihu.com/p/24814675</a></td><td align="center"><a href="http://example.com/#/foo/bar">http://example.com/#/foo/bar</a></td></tr><tr><td align="center">发送请求</td><td align="center">通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。会发一次请求</td><td align="center">hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。不会发请求</td></tr><tr><td align="center">优点</td><td align="center">更加直观和正式</td><td align="center">兼容性更好</td></tr><tr><td align="center">项目打包前自测</td><td align="center">默认看不到内容</td><td align="center">默认可以看到内容</td></tr></tbody></table><h3 id="子路由和动态路由"><a href="#子路由和动态路由" class="headerlink" title="子路由和动态路由"></a>子路由和动态路由</h3><p><em>动态路由</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 动态字段以冒号开始</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><em>子路由</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/profile 匹配成功</span></span><br><span class="line">        <span class="comment">// UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;profile&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">UserProfile</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">        <span class="comment">// UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">UserPosts</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="路由传值"><a href="#路由传值" class="headerlink" title="路由传值"></a>路由传值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">uname</span>: <span class="variable language_">this</span>.<span class="property">userName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">uname</span>: <span class="variable language_">this</span>.<span class="property">userName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="导航故障"><a href="#导航故障" class="headerlink" title="导航故障"></a>导航故障</h3><p>当使用 <code>router-link</code> 组件时，Vue Router 会自动调用 <code>router.push</code> 来触发一次导航。 有些情况会留在同一页面上：</p><ul><li>用户已经位于他们正在尝试导航到的页面</li><li>一个<a href="https://v3.router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>通过调用 <code>next(false)</code> 中断了这次导航</li><li>一个<a href="https://v3.router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>抛出了一个错误，或者调用了 <code>next(new Error())</code></li></ul><p>当使用 <code>router-link</code> 组件时，这些失败都不会打印出错误。如果你使用 <code>router.push</code> 或者 <code>router.replace</code> 的话，可能会在控制台看到一条 <em>“Uncaught (in promise) Error”</em> 这样的错误，后面跟着一条更具体的消息。</p><p>解决方法是在请求的后面打印抛出的错误。</p><h3 id="route-和-router"><a href="#route-和-router" class="headerlink" title="$route 和 $router"></a><code>$route</code> 和 <code>$router</code></h3><p><code>$route</code>是路由信息对象，里面主要包含路由的一些基本信息，包含当前的路径，参数，query对象等。(包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom)</p><p><em>route object 出现在多个地方:</em></p><ol><li>组件内的 this.route和route watcher 回调（监测变化处理）;</li><li>router.match(location) 的返回值</li><li>scrollBehavior 方法的参数</li></ol><p>方法：</p><ol><li><code>$route.path</code> 字符串，对应当前路由的路径，总是解析为绝对路径，如 “&#x2F;foo&#x2F;bar”</li><li><code>$route.params</code> 一个 key&#x2F;value 对象，包含了 动态片段 和 全匹配片段，<br>   如果没有路由参数，就是一个空对象。</li><li><code>$route.query</code>  一个 key&#x2F;value 对象，表示 URL 查询参数。<br>   例如，对于路径 &#x2F;foo?user&#x3D;1，则有 $route.query.user &#x3D;&#x3D; 1, 如果没有查询参数，则是个空对象。</li><li><code>$route.hash</code> 当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点</li><li><code>$route.fullPath</code> 完成解析后的 URL，包含查询参数和 hash 的完整路径。</li><li><code>$route.matched</code> 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</li><li><code>$route.name</code>  当前路径名字</li><li><code>$route.meta</code>  路由元信息</li></ol><p><code>$router</code>对象是全局路由的实例，是router构造方法的实例,包含了一些路由的跳转方法，钩子函数等</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=123</span></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;123&#x27;</span> &#125;&#125;)</span><br><span class="line"><span class="comment">// 页面路由跳转 前进或者后退</span></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">go</span>(-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 一般使用replace来做404页面</span></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">replace</span>(<span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p><em>全局守卫</em>  <strong>(使用不多)</strong></p><p><code>router.beforeEach(fn)</code>: 全局前置路由守卫</p><p><code>afterEach(fn)</code>: 全局后置路由守卫, 表示离开当前路由时执行</p><p>fn中有三个参数</p><ul><li>to:表示要去哪里</li><li>from：表示从哪里来</li><li>next：表示通不通过</li></ul><p>关于<code>next()</code>的使用</p><ul><li><code>next()</code> 等价于 next( true ) 表示可以从当前路由跳转到目标路由</li><li><code>next( false )</code> 表示不通过， 表示从当前路由跳转不到目标路由</li><li><code>next(’/login’)</code> 等价于 next({path:’&#x2F;login’,params,query}), 跳转指定的路由</li><li>next( fn ) 数据预加载</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>( <span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;name&#x27;</span>);<span class="comment">//查看本地存储上是否有name对象</span></span><br><span class="line">    <span class="keyword">if</span>( name || to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>)&#123;<span class="comment">//短路逻辑，有就可以继续执行，没有就跳转到登录页面</span></span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="title function_">next</span>( <span class="string">&#x27;/login&#x27;</span> )<span class="comment">//跳转登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">afterEach</span>( <span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(to.<span class="property">path</span> === <span class="string">&#x27;/user&#x27;</span>)&#123;<span class="comment">//当to的path值等于这个时</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;确定进入user吗&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><em>全局的解析守卫</em></p><p>  在 <code>2.5.0+</code>你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。必须保证整个项目的守卫和异步路由组件解析完成</p><p><em>路由独享守卫</em>——<strong>写在路由表里</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line"><span class="attr">beforeEnter</span>: <span class="function">(<span class="params"> to,<span class="keyword">from</span>,next </span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(to)</span></span><br><span class="line">    <span class="keyword">const</span> name = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;name&#x27;</span>);<span class="comment">//判断本地存储有没有name对象</span></span><br><span class="line">    <span class="keyword">if</span>( name)&#123;<span class="comment">//存在就可以继续执行</span></span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;你还没有登录，点击跳转登录&#x27;</span>)<span class="comment">//不存在就弹窗告诉没有登录，点击登录</span></span><br><span class="line">                <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><em>组件内守卫</em> <strong>(不推荐用)</strong></p><ul><li>beforeRouteEnther( (to,from,next) &#x3D;&gt;{} ) 进入组件时触发</li><li>beforeRouteUpdate( (to,from,next) &#x3D;&gt;{} ) 数据改变时触发</li><li>beforeRouteLeave( (to,from,next) &#x3D;&gt;{} ) 离开组件时触发</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断两个输入框是否有值输入，有就可以直接离开，没有弹窗告诉确定是否离开，防止误触</span></span><br><span class="line"><span class="title function_">beforeRouteLeave</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">username</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">pwd</span>)&#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">confirm</span>(<span class="string">&#x27;你确定要离开吗&#x27;</span>))&#123;<span class="comment">//返回一个布尔值</span></span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听路由"><a href="#监听路由" class="headerlink" title="监听路由"></a>监听路由</h3><ol><li><p>使用 <code>watch</code> 监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">  $router(to,<span class="keyword">from</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(to.<span class="property">path</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>beforeRouteUpdate</code> 监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> web前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> vuex </tag>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（三）</title>
      <link href="/2024/04/15/48498/"/>
      <url>/2024/04/15/48498/</url>
      
        <content type="html"><![CDATA[<h3 id="图的简介"><a href="#图的简介" class="headerlink" title="图的简介"></a>图的简介</h3><p>图用于表示任何二元关系</p><p>JS中没有图，但可以用 <code>Object</code> 和 <code>Array</code> 构建图</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph</span><br><span class="line"><span class="number">0</span>:[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"><span class="number">1</span>:[<span class="number">2</span>],</span><br><span class="line"><span class="number">2</span>:[<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>:[<span class="number">3</span>]<span class="number">1</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><p>图的表示方法：邻接矩阵，邻接表，关联矩阵</p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><h3 id="DFS和BFS"><a href="#DFS和BFS" class="headerlink" title="DFS和BFS"></a>DFS和BFS</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>思路：1. 访问根节点。 2. 深度优先访问根节点的未访问的相邻节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="built_in">require</span>(./graph);</span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">const</span> dfs (n)=&gt;&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">visited.<span class="title function_">add</span>(n);</span><br><span class="line">graph[n].<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(!visited.<span class="title function_">has</span>(c))  <span class="title function_">dfs</span>(c);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>思路：1. 新建一个队列，将根节点入队。 2. 出队一个节点，然后把未访问过的相邻节点入队。 3. 重复步骤直到队为空</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="built_in">require</span>(./graph);</span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bfs</span> = n =&gt; &#123;</span><br><span class="line">    list.<span class="title function_">push</span>(n)</span><br><span class="line">    visited.<span class="title function_">add</span>(n)</span><br><span class="line">    <span class="keyword">while</span> (list.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = list.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">        graph[x].<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(c)) &#123;</span><br><span class="line">                list.<span class="title function_">push</span>(c)</span><br><span class="line">                visited.<span class="title function_">add</span>(c)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><ol><li>65：有效数字</li><li>417：太平洋大西洋水流问题</li><li>133：克隆图</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法逻辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（一）</title>
      <link href="/2024/04/15/8561/"/>
      <url>/2024/04/15/8561/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法逻辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 集合 </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react基本使用</title>
      <link href="/2024/04/15/55678/"/>
      <url>/2024/04/15/55678/</url>
      
        <content type="html"><![CDATA[<h2 id="react项目创建和目录结构"><a href="#react项目创建和目录结构" class="headerlink" title="react项目创建和目录结构"></a>react项目创建和目录结构</h2><ol><li><p>创建项目</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app &lt;projectName&gt;</span><br></pre></td></tr></table></figure></li><li><p>核心库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDom from &#x27;react-dom/client&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A[App组件] --&gt; B[Page1组件]</span><br><span class="line">    A[App组件] --&gt; C[Page2组件]</span><br><span class="line">    A[App组件]--&gt; D[Html中的id为root的div]</span><br><span class="line">    D[Html中的id为root的div]--&gt; E[项目显示]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>其中，<code>Page1</code> 和 <code>Page2</code> 组件为 <code>App</code> 的子组件，由React库负责生成</p><p>App组件转化为DOM的过程由 <code>react-dom</code> 负责</p></li><li><p>根组件渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 渲染你的 React 组件</span><br><span class="line">const root = createRoot(document.getElementById(&#x27;app&#x27;));</span><br><span class="line">root.render(&lt;h1&gt;Hello, world&lt;/h1&gt;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="react组件和jsx"><a href="#react组件和jsx" class="headerlink" title="react组件和jsx"></a>react组件和jsx</h2><h3 id="react-组件"><a href="#react-组件" class="headerlink" title="react 组件"></a><code>react</code> 组件</h3><ol><li><p>函数组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function Profile() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;</span><br><span class="line">      alt=&quot;Katherine Johnson&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>export default</code>它导出文件中的主要函数以便你以后可以从其他文件引入它。</p></li><li><p>类组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Profile() extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">      return </span><br><span class="line">      &lt;img</span><br><span class="line">      src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;</span><br><span class="line">      alt=&quot;Katherine Johnson&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>导出、导入组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default function Gallery() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h1&gt;了不起的科学家&lt;/h1&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><ol><li><p>特点：由于<code>React</code>项目利用<code>babel</code>对语句进行编译，所以可以和js混用。本质是对JS语法的扩展。</p><p>使用 React 的 <code>creatElement</code> 方法也能创建组件但是不常用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default function Profile() &#123;</span><br><span class="line">  return React.creatElement(&#x27;img&#x27;, [</span><br><span class="line">      src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;,</span><br><span class="line">      alt=&quot;Katherine Johnson&quot;], </span><br><span class="line">                            &#x27;&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，<code>React</code> 和 <code>jsx</code> 语法是相互独立的，<code>creatElement</code> 方法会创建一个 <code>React.Element</code> 对象(虚拟DOM)，进而渲染成节点。</p></li><li><p>jsx 的 <code>&#123;&#125;</code> 渲染原则</p><ol><li>字符串，数字：直接渲染</li><li>方法：无法渲染</li><li>对象：无法渲染，只能渲染 <code>Element</code> 对象</li><li>布尔值：不渲染</li><li>undefined，null：不渲染</li><li>数组：每一项单独渲染</li><li>表达式：运行之后渲染</li></ol></li></ol><h2 id="react的事件绑定"><a href="#react的事件绑定" class="headerlink" title="react的事件绑定"></a>react的事件绑定</h2><ol><li><p>react 事件绑定和原生js相似（首字母大写）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Click me</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>this</code>指向：</p><p><strong>不做任何处理，默认this指向 <code>undefined</code></strong></p><p>如果你像下面这样写事件监听函数，浏览器一定会给你报语法错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// JSX</span><br><span class="line">class Test extends React.Component &#123;</span><br><span class="line"> handleClick () &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line"> render () &#123;</span><br><span class="line"> return &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  // undefined</span><br></pre></td></tr></table></figure><p>此时如果你点击 <code>button</code> 按钮，会输出 <code>undefined</code>。</p><p>注意此处的**<code>return &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt;</code>**，<code>this.handleClick</code> 不带括号，<code>this.handleClick()</code>为函数调用。</p><p><em>解决方案：</em></p><p>我们知道你可以通过 <code>bind</code> 方法或者箭头函数来强制绑定 <code>this</code> 来避免这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>或者使用箭头函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>如果this没有绑定到当前对象，那此时 <code>this</code> 到底指向了谁？是 <code>undefined</code> 还是全局对象，比如 <code>window</code>？（根据前面提到的浏览器报错信息，答案显然是 <code>undefined</code>）</p></li><li><p>为什么 React 组件的实例会失去指向它本身的 <code>this</code> 指向？</p></li><li><p>这是 JavaScript 语言本身导致的还是 React 的内部某些原因导致的呢？</p><p><strong>知乎：<a href="https://zhuanlan.zhihu.com/p/37911534">深入解读 React 组件中的 “this</a></strong></p></li></ul><ol start="3"><li><p>事件绑定操作：</p><ol><li><p>事件传参：<code>bind(this, arg1, arg2 ... )</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p>事件对象：默认传递给方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// JSX</span><br><span class="line">class Test extends React.Component &#123;</span><br><span class="line"> handleClick (arg1,..., e) &#123;</span><br><span class="line">  console.log(e)</span><br><span class="line">  &#125;</span><br><span class="line"> render () &#123;</span><br><span class="line"> return &lt;button onClick=&#123;this.handleClick.bind(this, arg1...)&#125;&gt;&lt;/button&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  // undefined</span><br></pre></td></tr></table></figure></li><li><p>阻止默认行为和阻止冒泡</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleClick (arg1,..., e) &#123;</span><br><span class="line"> e.<span class="title function_">stopPropagation</span>()  <span class="comment">// 阻止冒泡</span></span><br><span class="line"> e.<span class="title function_">preventDefult</span>()  <span class="comment">//阻止默认行为</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="react中的响应式数据"><a href="#react中的响应式数据" class="headerlink" title="react中的响应式数据"></a>react中的响应式数据</h2><h2 id="条件渲染和列表循环"><a href="#条件渲染和列表循环" class="headerlink" title="条件渲染和列表循环"></a>条件渲染和列表循环</h2><h2 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h2><h2 id="props和组件间的传值，插槽"><a href="#props和组件间的传值，插槽" class="headerlink" title="props和组件间的传值，插槽"></a>props和组件间的传值，插槽</h2><h2 id="react中的样式操作"><a href="#react中的样式操作" class="headerlink" title="react中的样式操作"></a>react中的样式操作</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="实战编写增伤改查列表"><a href="#实战编写增伤改查列表" class="headerlink" title="实战编写增伤改查列表"></a>实战编写增伤改查列表</h2><h2 id="ref和context"><a href="#ref和context" class="headerlink" title="ref和context"></a>ref和context</h2><h2 id="函数组件和hook"><a href="#函数组件和hook" class="headerlink" title="函数组件和hook"></a>函数组件和hook</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react 进阶技巧</title>
      <link href="/2024/04/15/1/"/>
      <url>/2024/04/15/1/</url>
      
        <content type="html"><![CDATA[<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><h2 id="reac性能问题和优化"><a href="#reac性能问题和优化" class="headerlink" title="reac性能问题和优化"></a>reac性能问题和优化</h2><h2 id="react-router的使用"><a href="#react-router的使用" class="headerlink" title="react-router的使用"></a>react-router的使用</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> react-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react 实战技巧</title>
      <link href="/2024/04/15/2/"/>
      <url>/2024/04/15/2/</url>
      
        <content type="html"><![CDATA[<h2 id="react中的全局状态管理"><a href="#react中的全局状态管理" class="headerlink" title="react中的全局状态管理"></a>react中的全局状态管理</h2><h2 id="react中的路由权限控制"><a href="#react中的路由权限控制" class="headerlink" title="react中的路由权限控制"></a>react中的路由权限控制</h2><h2 id="组件库等相关生态"><a href="#组件库等相关生态" class="headerlink" title="组件库等相关生态"></a>组件库等相关生态</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构(二)</title>
      <link href="/2024/04/14/61802/"/>
      <url>/2024/04/14/61802/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法逻辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda虚拟环境配置</title>
      <link href="/2020/04/30/38XTJB/"/>
      <url>/2020/04/30/38XTJB/</url>
      
        <content type="html"><![CDATA[<h1 id="conda虚拟环境配置"><a href="#conda虚拟环境配置" class="headerlink" title="conda虚拟环境配置"></a>conda虚拟环境配置</h1><h2 id="Q1-虚拟环境常用命令"><a href="#Q1-虚拟环境常用命令" class="headerlink" title="Q1: 虚拟环境常用命令"></a>Q1: 虚拟环境常用命令</h2><ol><li><p>查看当前存在哪些虚拟环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env list </span><br><span class="line">conda info <span class="literal">-e</span></span><br></pre></td></tr></table></figure></li><li><p>检查更新当前conda</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure></li><li><p>Python创建虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n your_env_name python=x.x</span><br></pre></td></tr></table></figure><p>anaconda命令创建python版本为x.x，名字为your_env_name的虚拟环境。<strong>your_env_name文件可以在Anaconda安装目录envs文件下找到</strong>。</p></li><li><p>激活或者切换虚拟环境</p><p>打开命令行，输入python –version检查当前 python 版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux:  source activate your_env_nam</span><br><span class="line">Windows: activate your_env_name</span><br></pre></td></tr></table></figure></li><li><p>对虚拟环境中安装额外的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n your_env_name [package]</span><br></pre></td></tr></table></figure></li><li><p>关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deactivate env_name</span><br><span class="line">或者`activate root`切回root环境</span><br><span class="line">Linux下：source deactivate </span><br></pre></td></tr></table></figure></li><li><p>删除虚拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n your_env_name --all</span><br></pre></td></tr></table></figure></li><li><p>删除环境钟的某个包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name $your_env_name  $package_name </span><br></pre></td></tr></table></figure></li><li><p>设置国内镜像</p></li><li><p><a href="https://link.zhihu.com/?target=http://Anaconda.org">http://Anaconda.org</a>的服务器在国外，安装多个packages时，conda下载的速度经常很慢。清华TUNA镜像源有Anaconda仓库的镜像，将其加入conda的配置即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# 添加Anaconda的TUNA镜像</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line"></span><br><span class="line">\# 设置搜索时显示通道地址</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 清华源</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>中科院源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></li><li><p>恢复默认镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>转载自:</th></tr></thead><tbody><tr><td><a href="https://zhuanlan.zhihu.com/p/94744929">Anaconda-用conda创建python虚拟环境 - 知乎 (zhihu.com)</a></td></tr><tr><td><a href="https://blog.csdn.net/weixin_43975408/article/details/106051526">python、anaconda国内镜像源_中科院源-CSDN博客</a></td></tr></tbody></table><h2 id="Q2-使用命令或vscode创建的虚拟环境未命名无法安装包"><a href="#Q2-使用命令或vscode创建的虚拟环境未命名无法安装包" class="headerlink" title="Q2: 使用命令或vscode创建的虚拟环境未命名无法安装包"></a>Q2: 使用命令或vscode创建的虚拟环境未命名无法安装包</h2><p>2.在指定目录下建立conda虚拟环境</p><p>具体地，可以使用conda create –prefix&#x3D;your_path python&#x3D;X.X来在指定目录下建立conda虚拟环境。以D盘为例，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --prefix=D:/2023XinXiaoYan/envs/my_env python=3.8</span><br></pre></td></tr></table></figure><p>其中，<code>D:/2023XinXiaoYan/envs</code> 是我指定的用于建立 <code>conda</code> 虚拟环境的目录，<code>my_env</code> 是我虚拟环境的名字，大家对应修改为自己的即可。<code>python=3.8</code> 表示python的版本号为3.8。</p><p>3.可能会出现的一些问题</p><p>根据上述命令建立了 <code>conda</code> 虚拟环境后，然后接着 <code>conda activate your_env_name</code> 。结果发现出错了，如下：</p><p>如果你输入 <code>conda env list </code> 就会发现，虚拟环境虽然是创建成功了，但是没有名字呀！</p><p>这时我们可以输入 <code>conda config --show envs_dirs</code> 来查看一下当前的环境目录，如下。可以看到我们新建立的环境目录没有加进来！</p><p>因此，使用 <code>conda config --append envs_dirs your_path</code> 将我们的目录加进来。具体地，以我为例，如下。</p><p>加完环境目录后，再 <code>conda env list</code> 就可以看到我们的虚拟环境彻底建好了。</p><p>此时，我们再对虚拟环境进行激活，如下：</p><p>可以看到，成功进入了自己的虚拟环境。接着，我们就可以在自己的虚拟环境里下载或卸载各种包，而不用担心影响其他人的虚拟环境了。</p><hr><p>原文链接：<a href="https://blog.csdn.net/qq_40968179/article/details/127584615">https://blog.csdn.net/qq_40968179/article/details/127584615</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> question </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
